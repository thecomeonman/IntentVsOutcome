---
title: "Finding passers with good awareness"
output: md_document
---

This is a thinking out loud kind of post. A bunch of basic charts and numbers are here which should be enough to give an idea of what I'm proposing. I want to think about this some more, which is usually a long and slow process because life gets in the way, before doing a version with nice looking vizes, etc. + also get feedback and comments from you guys.

# Introduction

http://www.lukebornn.com/papers/fernandez_sloan_2019.pdf comes up with a probabilistic possession value based on combining the possession value of the part of the pitch, the probability of the ball being controlled in the part of the pitch from pitch control, and the probability of the ball being played to that part of the pitch from an action likelihood model. These numbers can then be used to infer passing tendencies, awareness, positioning, and many other things.

We'll exclude action likelihood for now, because I want to fairly evaluate any opportunity across the pitch without 

Pitch control and probably action likelihood are _outcome_ based models. Pitch control tells you the probability of controlling the ball if it were played to that part of the pitch. Action likelihood is also probably based on data from what _happened_ in actual matches. An additional aspect we need to model to evaluate things like player decision making is _intention_.

```{r setup, include=FALSE}

rm(list = ls())

library(data.table)
library(ggplot2)
library(scales)
library(CodaBonito)
library(knitr)
library(akima)

knitr::opts_chunk$set(
   echo = F,
   message = F,
   warning = F,
   fig.width = 12,
   fig.height = 6
)

```

```{r parameters, echo=FALSE}

cRootDirectory = '~/Desktop/Data/Projects/Personal'

nXSpan = 120
nYSpan = 80
nUpperLimitSpeed = 5 * 120 / 105
nMaxPassLength = nXSpan * 2/3

cGameName = 'Sample_Game_1'

dtPlayerLabels = rbind(
   data.table(
      Player = paste0(c(''), 2:12),
      Label = c(
         'RCB',
         'LCB',
         'LB',
         'RW',
         'LCM',
         'RB',
         'LW',
         'CF',
         'CAM',
         'GK',
         'RCM'
      )
   ),
   data.table(
      Player = paste0(c(''), 15:25),
      Label = c(
         'RCB',
         'CB',
         'RWB',
         'CM',
         'RCM',
         'LCB',
         'LCM',
         'LWB',
         'LF',
         'RF',
         'GK'
      )
   )
)

dtPlayerLabels[,
   Label := factor(
      Label,
      levels = c(
         'GK',
         'RCB','CB','LCB',
         'RB','LB','RWB','LWB',
         'CDM',
         'RCM','CM','LCM',
         'RW','RCAM','CAM','LCAM','LW',
         'RF','CF','LF'
      ),
      ordered = T
   )
]

AttackDeltaPVThreshold = 0.02
PlayerDeltaPVThreshold = 0.01

DataFrequency_hz = 25
```

```{r functions, echo=FALSE}


fGetEPV = function(
  vnX,
  vnY,
  nXSpan = 120,
  nYSpan = 80
) {
  
  dtEPV = fread(
      'https://raw.githubusercontent.com/Friends-of-Tracking-Data-FoTD/LaurieOnTracking/master/EPV_grid.csv',
      header = F
  )
  
  dtEPV[, y := .I]
  dtEPV = melt(dtEPV, 'y')
  setnames(dtEPV, 'variable','x')
  dtEPV[, x := gsub(x, pattern = 'V', replacement = '')]
  dtEPV[, x := as.integer(x)]
  
  # slightly corrupting the grid for better interpolation
  dtEPV[, x := x - min(x)]
  dtEPV[, y := y - min(y)]
  dtEPV[, x := x * ( nXSpan - (1/(5*nXSpan)) )  / max(x)]
  dtEPV[, y := y * ( nYSpan - (1/(5*nYSpan)) ) / max(y)]
  
  qwe = interp(
     dtEPV[,x],
     dtEPV[,y],
     dtEPV[,value],
     xo = seq(0, nXSpan - (1/(5*nXSpan)), length = ( 5 * nXSpan )),
     yo = seq(0, nYSpan - (1/(5*nYSpan)), length = ( 5 * nYSpan )),
     extrap = T, 
  )
  
  dtEPV = data.table(t(qwe$z))
  
  vnEPVGridX = seq(0, nXSpan - (1/(5*nXSpan)), nXSpan/(ncol(dtEPV)))
  vnEPVGridY = seq(0, nYSpan - (1/(5*nYSpan)), nYSpan/(nrow(dtEPV)))
  
  # vnEPVGridX[1] = vnEPVGridX[1] - 0.000000001
  # vnEPVGridY[1] = vnEPVGridY[1] - 0.000000001
  
  vnX = vnX + (nXSpan/2)
  vnY = vnY + (nYSpan/2)
  
  vnXIndex = 1 + ( vnX %/% (nXSpan/(ncol(dtEPV))) )
  vnXIndex[vnXIndex <= 0] = 1L
  vnXIndex[vnXIndex > ncol(dtEPV)] = ncol(dtEPV)
  vnYIndex = 1 + ( vnY %/% (nYSpan/nrow(dtEPV)) )
  vnYIndex[vnYIndex <= 0] = 1L
  vnYIndex[vnYIndex > nrow(dtEPV)] = nrow(dtEPV)
  
  dtEPV[, Y := .I]
  dtEPV = melt(dtEPV, 'Y')
  dtEPV[, X := as.integer(gsub(variable, pattern = 'V', replacement = ''))]

  merge(
    data.table(X = vnXIndex, Y = vnYIndex)[, SNO := .I],
    dtEPV,
    c('X','Y'),
    all.x = T
  )[order(SNO), value]
  
}


  fGetIntentValues = function(
    lMetadata,
    lPitchControl,
    lData
  ) {

    dtDetails = merge(
        lPitchControl$dtDetails[, list(SNO, Frame, TargetX, TargetY)],
        lPitchControl$dtTrackingSlice[
          Player == 0, 
          list(Frame, BallX = X, BallY = Y)
        ],
        'Frame'
    )
    
    dtDetails = merge(
        dtDetails,
        lPitchControl$dtTrackingSlice[
          TeamInPossession == T, 
          list(Frame, Player, Tag, AttackingTeam, TeamInPossession, PlayerInPossession)
        ],
        'Frame',
        allow.cartesian = T
    )
    
    dtDetails = merge(
        dtDetails,
        lPitchControl$dtTrackingSliceVectorised[
          , 
          list(SNO, Player, PlayerPPCF)
        ],
        c('SNO','Player')
    )
    
    if ( nrow(dtDetails) == 0 ) {
        stop()
    }
    
    if ( lMetadata$cTeam == 'H' ) {
        dtDetails[, AttackOriginPV := fGetEPV(BallX, BallY)]
        dtDetails[, AttackTargetPV := fGetEPV(TargetX, TargetY)]
        dtDetails[, DefenseTargetPV := fGetEPV(-TargetX, -TargetY)]
    } else {
        dtDetails[, AttackOriginPV := fGetEPV(-BallX, -BallY)]
        dtDetails[, AttackTargetPV := fGetEPV(-TargetX, -TargetY)]
        dtDetails[, DefenseTargetPV := fGetEPV(TargetX, TargetY)]
    }
    
    dtDetailsAggregated = dtDetails[
        , 
        list(
          AttackPPCF = sum(PlayerPPCF)
        ),
        list(
          Frame,
          Tag,
          AttackingTeam,
          TargetX,
          TargetY,
          BallX,
          BallY,
          AttackOriginPV,
          AttackTargetPV,
          DefenseTargetPV
        )
    ]
    
    
    dtDetailsAggregated[
        , 
        AttackDeltaPV := (
          (
              ( AttackPPCF * AttackTargetPV ) -
                ( ( 1 - AttackPPCF ) * ( DefenseTargetPV ) )
          ) - (
              1 * AttackOriginPV
          )
        )
    ]
    
    
    
    # dtDetails[, 
    #   PlayerDeltaPPCFContribution := ( PlayerPPCF / TeamPPCF ) * (2 * ( TeamPPCF - 0.5 ) ) 
    # ]
    dtDetailsAggregated[, Distance := ( ( (BallX - TargetX) ^ 2 ) + ( (BallY - TargetY) ^ 2 ) ) ^ 0.5]
    dtDetailsAggregated[, DistanceSD := Distance / 30]
    
    if ( F ) {
        dtDetailsAggregated = dtDetailsAggregated[
          , 
          data.table(expand.grid(
              TargetXIntent = seq(
                round(TargetX - (3*DistanceSD)),
                round(TargetX + (3*DistanceSD)),
                1
              ),
              TargetYIntent = seq(
                round(TargetY - (3*DistanceSD)),
                round(TargetY + (3*DistanceSD)),
                1
              )
          )),
          c(colnames(dtDetailsAggregated))
        ]
    }
    
    dtDetailsAggregated = merge(
        dtDetailsAggregated,
        dtDetailsAggregated[
          which.max(DistanceSD), 
          data.table(expand.grid(
              TargetXIntent = seq(
                round((-3*ceiling(DistanceSD))),
                round((+3*ceiling(DistanceSD))),
                1
              ),
              TargetYIntent = seq(
                round((-3*ceiling(DistanceSD))),
                round((+3*ceiling(DistanceSD))),
                1
              )
          ))[, Frame := dtDetailsAggregated[1, Frame]]
        ],
        'Frame',
        allow.cartesian = T
    )
    
    dtDetailsAggregated[
        ,
        DistanceIntent := (
          ( ( TargetXIntent ^ 2 ) + ( TargetYIntent ^ 2 ) ) ^ 0.5
        )
    ]
    
    dtDetailsAggregated = dtDetailsAggregated[
        DistanceIntent <= ( 3 * DistanceSD ) + (sqrt(2)/2)
    ]
    
    dtDetailsAggregated[, TargetXIntent := TargetX + TargetXIntent]
    dtDetailsAggregated[, TargetYIntent := TargetY + TargetYIntent]
    
    if ( F ) {
        
        dtDetailsAggregated[
          DistanceIntent <= DistanceSD - (sqrt(2)/2),
          Intersection := 1
        ]
        
        if ( F ) {
          
          fGetIntersection = function(
              TargetX,
              TargetY,
              DistanceSD,
              TargetXIntent,
              TargetYIntent,
              Resolution = 20
          ) {
              
              # browser()
              
              qwe = cbind(
                x = DistanceSD * sin(2*pi * seq(1,Resolution,1)/Resolution) + TargetX,
                y = DistanceSD * cos(2*pi * seq(1,Resolution,1)/Resolution) + TargetY
              )
              qwe = rbind(qwe[nrow(qwe),], qwe)
              asd = cbind(
                x = TargetXIntent + c(-0.5,+0.5,+0.5,-0.5,-0.5),
                y = TargetYIntent + c(+0.5,+0.5,-0.5,-0.5,+0.5)
              )
              
              # plot(qwe)
              # points(asd)
              
              s = st_sfc(
                list(
                    st_polygon(list(asd)),
                    st_polygon(list(qwe))
                )
              )
              zxc = st_intersection(s)
              
              st_area(data.frame(zxc)[1,]) / (st_area(data.frame(zxc)[1,]) + st_area(data.frame(zxc)[2,]))
              
          }
          
          dtDetailsAggregated[
              is.na(Intersection),
              Intersection := fGetIntersection(
                TargetX[Tag == Tag[1]],
                TargetY[Tag == Tag[1]],
                pmax(0.01,DistanceSD[Tag == Tag[1]]),
                TargetXIntent[Tag == Tag[1]],
                TargetYIntent[Tag == Tag[1]]
              ),
              list(
                Frame, TargetX, TargetY,TargetXIntent, TargetYIntent
              )
          ]
          
        } else if ( F ) {
          
          dtDetailsAggregated[
              is.na(Intersection),
              Intersection := fGetIntersection(
                TargetX,
                TargetY,
                pmax(0.01,DistanceSD),
                TargetXIntent,
                TargetYIntent
              )
          ]
          
        }
        
    }
    
    dtDetailsAggregated[, PDF := dnorm(DistanceIntent,0,DistanceSD)]
    dtDetailsAggregated[, PDF := PDF/sum(PDF), list(Frame, Tag, BallX, BallY, TargetX, TargetY)]
    
    dtDetailsAggregated = merge(
        dtDetailsAggregated,
        dtDetailsAggregated[, 
                            list(AttackPPCFIntent = AttackPPCF[1]), 
                            list(
                              TargetXIntent = TargetX, 
                              TargetYIntent = TargetY,
                              Tag,
                              Frame
                            )
        ],
        c('Frame','Tag','TargetXIntent','TargetYIntent'),
        all.x = T
    )
    
    # should be out of bounds areas only
    dtDetailsAggregated[
        is.na(AttackPPCFIntent),
        AttackPPCFIntent := 0
    ]
    
    TRAngle = atan2(
        (( nYSpan/2) - dtDetailsAggregated[1,BallY]),
        (( nXSpan/2) - dtDetailsAggregated[1,BallX])
    ) %% (2*pi)
    
    TLAngle = atan2(
        (( nYSpan/2) - dtDetailsAggregated[1,BallY]),
        ((-nXSpan/2) - dtDetailsAggregated[1,BallX])
    ) %% (2*pi)
    
    BLAngle = atan2(
        ((-nYSpan/2) - dtDetailsAggregated[1,BallY]),
        ((-nXSpan/2) - dtDetailsAggregated[1,BallX])
    ) %% (2*pi)
    
    BRAngle = atan2(
        ((-nYSpan/2) - dtDetailsAggregated[1,BallY]),
        (( nXSpan/2) - dtDetailsAggregated[1,BallX])
    ) %% (2*pi)
    
    dtDetailsAggregated[
        abs(TargetXIntent) > nXSpan/2 | abs(TargetYIntent) > nYSpan/2,
        Angle := atan2(
          (TargetYIntent - BallY),
          (TargetXIntent - BallX)
        ) %% (2*pi)
    ]
    
    dtDetailsAggregated[
        ( abs(TargetXIntent) > nXSpan/2 | abs(TargetYIntent) > nYSpan/2 ) &
        Angle >= TRAngle & Angle < TLAngle,
        Outside := 'T'
    ]
    
    dtDetailsAggregated[
        ( abs(TargetXIntent) > nXSpan/2 | abs(TargetYIntent) > nYSpan/2 ) &
          Angle >= TLAngle & Angle < BLAngle,
        Outside := 'L'
    ]
    
    dtDetailsAggregated[
        ( abs(TargetXIntent) > nXSpan/2 | abs(TargetYIntent) > nYSpan/2 ) &
          Angle >= BLAngle & Angle < BRAngle,
        Outside := 'B'
    ]
    
    dtDetailsAggregated[
        ( abs(TargetXIntent) > nXSpan/2 | abs(TargetYIntent) > nYSpan/2 ) &
          (
              Angle >= BRAngle & Angle < (2*pi) |
              Angle >= 0 & Angle < TRAngle
          ),
        Outside := 'R'
    ]
    
    # ggplot(dtDetailsAggregated[,.SD[1], list(TargetXIntent, TargetYIntent)]) + 
    #    geom_point(aes(TargetXIntent, y = TargetYIntent, color = Outside)) +
    #    geom_point(data = dtDetailsAggregated[1], aes(x = BallX, y = BallY), size = 3)
    
    if ( lMetadata$cTeam == 'H' ) {
        
        # ~goal kick
        dtDetailsAggregated[
          Outside == 'R',
          c('TargetXIntent','TargetYIntent') := list(nXSpan/2,0)
        ]
        
        # corners
        dtDetailsAggregated[
          ( Outside == 'L' & TargetYIntent < 0 ),
          c('TargetXIntent','TargetYIntent') := list(-nXSpan/2,-nYSpan/2)
        ]
        
        dtDetailsAggregated[
          ( Outside == 'L' & TargetYIntent > 0 ),
          c('TargetXIntent','TargetYIntent') := list(-nXSpan/2,nYSpan/2)
        ]
        
    } else {
        
        # goal kick
        dtDetailsAggregated[
          Outside == 'L',
          c('TargetXIntent','TargetYIntent') := list(-nXSpan/2,0)
        ]
        
        # corners
        dtDetailsAggregated[
          ( Outside == 'R' & TargetYIntent < 0 ),
          c('TargetXIntent','TargetYIntent') := list(nXSpan/2,-nYSpan/2)
        ]
        
        dtDetailsAggregated[
          ( Outside == 'R' & TargetYIntent > 0 ),
          c('TargetXIntent','TargetYIntent') := list(nXSpan/2,nYSpan/2)
        ]
        
    }
    
    dtDetailsAggregated[
        Outside %in% c('T'),
        TargetXIntent := (
          ( TargetXIntent - BallX ) * 
              ( ( nYSpan/2 ) - BallY ) / 
              ( TargetYIntent - BallY )
        ) + BallX
    ]
    
    dtDetailsAggregated[
        Outside %in% c('B'),
        TargetXIntent := (
          ( TargetXIntent - BallX ) * 
              ( ( -nYSpan/2 ) - BallY ) / 
              ( TargetYIntent - BallY )
        ) + BallX
    ]
    
    dtDetailsAggregated[
        Outside %in% c('T','B') & TargetYIntent > nYSpan/2,
        TargetXIntent := 0.5 + round(TargetXIntent - 0.5)
    ]
    
    dtDetailsAggregated[
        Outside %in% c('T'),
        TargetYIntent := nYSpan/2
    ]
    
    dtDetailsAggregated[
        Outside %in% c('B'),
        TargetYIntent := -nYSpan/2
    ]
    
    if ( lMetadata$cTeam == 'H' ) {
        
        dtDetailsAggregated[
          , 
          AttackTargetPVIntent := fGetEPV(TargetXIntent, TargetYIntent),
          # list(TargetXIntent, TargetYIntent)
        ]
        dtDetailsAggregated[
          , 
          DefenseTargetPVIntent := fGetEPV(-TargetXIntent, -TargetYIntent),
          # list(TargetXIntent, TargetYIntent)
        ]
        
    } else {
        
        dtDetailsAggregated[
          , 
          AttackTargetPVIntent := fGetEPV(-TargetXIntent, -TargetYIntent),
          # list(TargetXIntent, TargetYIntent)
        ]
        dtDetailsAggregated[
          , 
          DefenseTargetPVIntent := fGetEPV(TargetXIntent, TargetYIntent),
          # list(TargetXIntent, TargetYIntent)
        ]
        
    }
    
    dtDetailsAggregated[
        !is.na(Outside),    
        AttackTargetPVIntent := 0
    ]
    
    
    dtDetailsAggregated = dtDetailsAggregated[
        , 
        list(
          AttackDeltaPVIntent = sum(
              PDF * (
                (
                    ( AttackPPCFIntent * AttackTargetPVIntent ) -
                    ( ( 1 - AttackPPCFIntent ) * ( DefenseTargetPVIntent ) )
                ) - (
                    1 * AttackOriginPV
                )
              )
          ),
          AttackPPCFIntent = sum(PDF * AttackPPCFIntent),
          AttackTargetPVIntent = sum(PDF * AttackTargetPVIntent),
          DefenseTargetPVIntent = sum(PDF * DefenseTargetPVIntent),
          CountIntent = .N
        ),
        list(
          Frame,
          Tag,
          AttackingTeam,
          TargetX,
          TargetY,
          BallX,
          BallY,
          AttackOriginPV,
          AttackTargetPV,
          DefenseTargetPV,
          AttackPPCF,
          AttackDeltaPV,
          Distance,
          DistanceSD
        )
    ]
    
    
    dtDetailsAggregatedPlayer = rbind(
        dtDetails[
          Tag == lMetadata$cTeam, 
          list(
              PlayerPPCF = sum(PlayerPPCF)
          ), 
          list(
              Frame,
              Tag,
              Player,
              TargetX,
              TargetY
          )
        ],
        merge(
          lData$dtTrackingData[
              Frame %in% dtDetails[, Frame] &
              !Player %in% dtDetails[, c(0, Player)] &
              Tag == lMetadata$cTeam,
              list(Frame, Player, Tag)
          ],
          dtDetails[
              , 
              list(
                PlayerPPCF = 0
              ), 
              list(
                Frame,
                TargetX,
                TargetY
              )
          ],
          c('Frame'),
          allow.cartesian = T
        )
    )
    
    dtDetailsAggregatedPlayer = merge(
        dtDetailsAggregated,
        dtDetailsAggregatedPlayer,
        c('Frame','Tag','TargetX','TargetY'),
        all = T
    )
    
    dtDetailsAggregatedPlayer[
        ,
        PlayerDeltaPV := AttackDeltaPV * PlayerPPCF / AttackPPCF
    ]
    
    # todo PlayerPPCFIntent / TeamPPCFIntent
    dtDetailsAggregatedPlayer[
        ,
        PlayerPPCFIntent := AttackPPCFIntent * PlayerPPCF / AttackPPCF
    ]
    
    dtDetailsAggregatedPlayer[
        ,
        PlayerDeltaPVIntent := AttackDeltaPVIntent * PlayerPPCFIntent / AttackPPCFIntent
    ]
    
    
    list(
        dtDetailsAggregated = dtDetailsAggregated,
        dtDetailsAggregatedPlayer = dtDetailsAggregatedPlayer
    )
    
  }


```

```{r data, echo=FALSE}

lData = fParseTrackingDataBothTeams(
  cRootPath = file.path(cRootDirectory,'/sample-data/data/'),
  cGameName = cGameName,
  nXSpan = nXSpan,
  nYSpan = nYSpan,
  xMaxBB = 1,
  yMaxBB = 1,
  nUpperLimitSpeed = nUpperLimitSpeed
)

dtPVDelta = readRDS(file.path(cRootDirectory, 'PassingAwareness/PVDelta.Rdata'))

dtPVDelta[, Team := Tag]
dtPVDelta[Tag == 'A', BallX := -BallX]
dtPVDelta[Tag == 'A', BallY := -BallY]
dtPVDelta[Tag == 'A', PlayerMaxDeltaPVX := -PlayerMaxDeltaPVX]
dtPVDelta[Tag == 'A', PlayerMaxDeltaPVY := -PlayerMaxDeltaPVY]
dtPVDelta[Tag == 'A', AttackMaxDeltaPVX := -AttackMaxDeltaPVX]
dtPVDelta[Tag == 'A', AttackMaxDeltaPVY := -AttackMaxDeltaPVY]
dtPVDelta[Tag == 'A', PlayerMaxDeltaPVIntentX := -PlayerMaxDeltaPVIntentX]
dtPVDelta[Tag == 'A', PlayerMaxDeltaPVIntentY := -PlayerMaxDeltaPVIntentY]
dtPVDelta[Tag == 'A', AttackMaxDeltaPVIntentX := -AttackMaxDeltaPVIntentX]
dtPVDelta[Tag == 'A', AttackMaxDeltaPVIntentY := -AttackMaxDeltaPVIntentY]

```

## Methodology

### Pitch Control

Pitch control tells you the probability of a team and its players controlling the ball at various parts of the pitch if the ball were to be passed there. This is done for each instant of the game and changes based on the positions of the players and their movement. 

I use Spearman's model but you could probably swap it out for any other model too.

### Possession Value

The probability of scoring at the end of a play / in the next some moves / in the next some seconds once the team has a ball in a particular part of the pitch.

I've used the PV grid at https://raw.githubusercontent.com/Friends-of-Tracking-Data-FoTD/LaurieOnTracking/master/EPV_grid.csv which looks like this for the team attacking left to right -

```{r PVParms, echo=FALSE}

if ( F ) {
   
   nCompoundingFactor = 1
   nNumeratorFactor = 0.9
   
   ggplot() + 
      geom_line(
         data = data.table(
            Distance = seq(
               0,
               ceiling(
                  ( 
                     ( 120 ^ 2 ) +
                     ( 40 ^ 2 )
                  ) ^ ( 0.5 * nCompoundingFactor )
               ),
               1
            )
         )[,
            PV := nNumeratorFactor / ( Distance + 1 )
         ],
         aes(
            x = Distance,
            y = PV
         )
      ) +
      labs(
         x = 'Distance from goal',
         y = 'Possession value'
      ) +
      scale_y_continuous(labels = percent)
   
} else if ( T ) {
   
   dtPitchGrid = expand.grid(
      x = seq(-nXSpan/2, nXSpan/2, 1),
      y = seq(-nYSpan/2, nYSpan/2, 1)
   )
   setDT(dtPitchGrid)
   
   dtPitchGrid[,
      PV := fGetEPV(
         x,
         y
      )
   ]
   
   p1 = ggplot(dtPitchGrid) +
      geom_tile(
        aes(x = x, y = y, fill = PV)
       ) +
       geom_pitch(cPitchColour = 'transparent', cLineColour = '#CCCCCC') +
       scale_fill_continuous(low = 'white', high = 'red', limits = c(0,1), labels = percent) +
       theme_pitch()
   
   print(p1)
   
}

```

We can rotate the pitch 180 degrees and get the PV values for the respective part of the pitch for the opposition since that team is attacking right to left.

Note how the probability sharply climbs close to 50% near the opposition goal but is quite low for most of the pitch.

You should be able to swap it out for another PV model, if you so prefer.

### Model 3

I don't have a good model for this yet and don't know of o public one either. I will try and explain what I'm doing without this model for now. I can't say how much the results carry over when this model gets included though.

### Combining Pitch Control and Possession Value

You should be able to combine these to evaluate what passing options offer progress to the team in possession.

- The team in possession already has a certain PV depending on where they have the ball: `AttackOriginPV`
- The defending team is equally at risk of conceding a goal from that position, so the `DefenseOriginPV = -AttackOriginPV`
- Assuming it is possible to pass to every point on the pitch, `(x,y)`, the PV for each target location can be calculated for both the teams, `AttackTargetPV_xy` and `DefenseTargetPV_xy`
- At every point on the pitch, `(x,y)`, the attacking team has a probability of keeping control of the ball, `AttackProbabilty_xy`, and therefore the defending team's probability is `DefenseProbabilty_xy = 1 - AttackProbabilty_xy`
- At every point, `(x,y)`, we can estimate an expected PV for playing a pass there:
   - For the attacking team, `ExpectedAttackTargetPV = ( AttackProbabilty_xy * AttackTargetPV_xy ) - ( DefenseProbabilty_xy * DefenseTargetPV_xy )`
   - For the defending team, which is the same as the above formula with the attacking / defending terms exchanged, `ExpectedDefenseTargetPV = ( DefenseProbabilty_xy * DefenseTargetPV_xy ) - ( AttackProbabilty_xy * AttackTargetPV_xy )`
- The change in PV from the current position can be calculated as the difference of the above terms from the PV of the starting position:
    - For the attacking team, `ExpectedAttackingDeltaPV_xy = ExpectedAttackTargetPV_xy - AttackOriginPV`
    - For the defending team, `ExpectedDefenseingDeltaPV_xy = ExpectedDefenseTargetPV_xy - DefenseingOriginPV`

Given we know the PV of each part of the pitch for both teams, and we know that the probability of controlling the ball for both teams must add up to 1 in each part of the pitch, we can calculate the minimum value `ExpectedAttackTargetPV_xy` must be in each part of the pitch for it to compensate for `ExpectedDefenseingDeltaPV_xy`, and therefore we can also calculate the minimum value `AttackProbabilty_xy` should be for `ExpectedAttackTargetPV_xy` to attain the necessary value. Think of this value for `AttackProbabilty_xy` as a kind of breakeven probability. This is what those probabilities look like -

```{r PVBreakEven, echo=FALSE}

dtPitchGrid = merge(dtPitchGrid,dtPitchGrid[, list(x = -x, y = -y, OppositionPV = PV)], c('x','y'))

dtPitchGrid[, BreakevenProbability := OppositionPV / ( PV + OppositionPV )]

p2 = ggplot(dtPitchGrid) +
   geom_tile(
     aes(x = x, y = y, fill = BreakevenProbability)
    ) +
    geom_pitch(cPitchColour = 'transparent', cLineColour = '#CCCCCC') +
    scale_fill_continuous(low = 'white', high = 'red', limits = c(0,1)) +
    theme_pitch()

print(p2)

```

Note how the breakeven probabilities are very low close to the opposition goal, because in that area the PV is very high for the attacking team compared to the PV for the defending team. In fact right at the goal mouth, the breakeven probability is `r dtPitchGrid[x == nXSpan/2 & y == 0, BreakevenProbability]`. This part of the pitch is a little hard to work with though because goalkeepers are also modelled as outfield players in this pitch control model whereas in reality they would actually exert far greater control than the model gives them credit for because they can use their hands, grab the ball in the air, dive, etc. which the other players cannot do. The pitch control models don't model shots either, it models passes, so the idea of 'passing to the goal' is aso a little odd. We will see later that this situation occurs in very few frames though so for now we will pretend this isn't a problem and carry on. 

I also ignore the possibility of passes that travel more than 2/3 the length of the pitch. Only Ederson can make such passes. We consider the area that is within a radius of 2/3 length of the pitch at any point of time and ignore everything outside of it.

We can expect `ExpectedDefenseDeltaPV_xy` to be positive very often, since `DefenseOriginPV` is a negative value so the more interesting thing to analyse would be `ExpectedAttackingDeltaPV_xy`. A positive `ExpectedAttackingDeltaPV_xy` implies that passing the ball to that point on the pitch is likely to increase the chance of scoring even after considering the risk of conceding the ball.

## Demonstration

### An Example Frame

I use one frame to give an example of how all that I said above comes together. I chose this example because it also highlights the problem I mentioned above while hopefully also giving you an idea of the concept.

```{r IllustrationData, echo=FALSE}

load(
   file.path(
      cRootDirectory,
      'PassingAwareness',
      'ProgressivePassingOpportunity',
      cGameName,
      'Actual',
      '2',
      'Results',
      '67776.Rdata'
   )
)

load(
   file.path(
      cRootDirectory,
      'PassingAwareness',
      'ProgressivePassingOpportunity',
      cGameName,
      'Actual',
      '2',
      'Metadata.Rdata'
   )
)

```

Here is what the pitch control looks like in one of the frames. In my calculations I exclude players that are offside so the two players from the blue team in the offside position have zero contribution to pitch control.

```{r PitchControlIllustation, echo=FALSE}

ggplot() + 
    geom_tile(
        data = lPitchControl$dtDetails,
        aes(x = TargetX, y = TargetY, fill = AttackProbability)
    ) +
    geom_point(
        data = lPitchControl$dtTrackingSlice[Tag == 'B'],
        aes(x = X, y = Y),
        color = 'black',
        size = 3
    ) +
    geom_point(
        data = lPitchControl$dtTrackingSlice[Tag != 'B'],
        aes(x = X, y = Y),
        color = 'black',
        size = 2
    ) +
    geom_point(
        data = lPitchControl$dtTrackingSlice[Tag != 'B'],
        aes(x = X, y = Y),
        color = 'black',
        size = 2
    ) +
    geom_point(
        data = lPitchControl$dtTrackingSlice[Tag != 'B'],
        aes(x = X, y = Y, color = Tag)
    ) +
    geom_pitch(cPitchColour = 'transparent', cLineColour = '#CCCCCC') +
    scale_fill_gradient2(midpoint = 0.5, low = 'red', high = 'blue') +
    theme_pitch()
    
```

When you overlay the possession value and do all those calculations listed above, this is what the pitch looks like in terms of `ExpectedAttackingDeltaPV_xy`.

```{r EPVIllustationTeam, echo=FALSE}

dtDetails = merge(
  lPitchControl$dtDetails[, list(SNO, Frame, TargetX, TargetY)],
  lPitchControl$dtTrackingSlice[
      Player == 0, 
      list(AttackingTeam, Frame, BallX = X, BallY = Y)
  ],
  'Frame'
)

dtDetails = merge(
  dtDetails,
  lPitchControl$dtTrackingSlice[, 
      list(Frame, Player, Tag, TeamInPossession, PlayerInPossession)
  ],
  'Frame',
  allow.cartesian = T
)

dtDetails = merge(
  dtDetails,
  lPitchControl$dtTrackingSliceVectorised[, 
    list(SNO, Player, PlayerPPCF)
  ],
  c('SNO','Player')
)

if ( nrow(dtDetails) == 0 ) {
  stop()
}


if ( lMetadata$cTeam == 'H' ) {
  dtDetails[, OriginPV := fGetEPV(BallX, BallY)]
} else {
  dtDetails[, OriginPV := fGetEPV(-BallX, -BallY)]
}

dtDetails[AttackingTeam != Tag, OriginPV := -OriginPV]

dtDetails[Tag == 'H', TeamTargetPV := fGetEPV(TargetX, TargetY)]
dtDetails[Tag == 'A', TeamTargetPV := fGetEPV(-TargetX, -TargetY)]
dtDetails[Tag == 'H', OppositionTargetPV := fGetEPV(-TargetX, -TargetY)]
dtDetails[Tag == 'A', OppositionTargetPV := fGetEPV(TargetX, TargetY)]

dtDetailsAggregated = dtDetails[, 
  list(
    AttackPPCF = sum(PlayerPPCF)
  ),
  list(
    Frame,
    Tag,
    TargetX,
    TargetY,
    BallX,
    BallY,
    TeamTargetPV,
    OppositionTargetPV,
    OriginPV
  )
]

dtDetailsAggregated[, 
  AttackDeltaPV := (
    ( AttackPPCF * TeamTargetPV ) -
    ( ( 1 - AttackPPCF ) * ( OppositionTargetPV ) )
  ) - (
    1 * OriginPV
  )
]

    
p1 = ggplot() + 
    geom_tile(
        data = dtDetailsAggregated[lPitchControl$dtTrackingSlice[1, AttackingTeam] == Tag],
        aes(x = TargetX, y = TargetY, fill = AttackDeltaPV)
    ) +
    geom_point(
        data = lPitchControl$dtTrackingSlice[Tag == 'B'],
        aes(x = X, y = Y),
        color = 'black',
        size = 3
    ) +
    geom_point(
        data = lPitchControl$dtTrackingSlice[Tag != 'B'],
        aes(x = X, y = Y, color = Tag)
    ) +
    geom_pitch(cPitchColour = 'transparent', cLineColour = '#CCCCCC') +
    scale_fill_gradient2(midpoint = 0, high = 'blue', low = 'red') +
    theme_pitch()
    
print(p1)

```

There is some territory in the middle of the pitch where passing the ball is expected to return a positive `ExpectedAttackingDeltaPV_xy`. And then there is the tricky area near the opposition goal, which has a larger `ExpectedAttackingDeltaPV_xy` than the middle of the pitch. As a result of this problem, the logic above would suggest that in this situation the optimal action for the team in possession, the blue team, should be to pass the ball all the way to the goal and hope that the small chance of another player from the same team controlling the ball pays off for the high reward you'd get from successfully controlling the ball at that location.

```{r EPVIllustationTeamOptimal, echo=FALSE}

if ( F ) {
      
   p1 = p1 + 
      geom_tile(
           data = dtDetailsAggregated[Tag == lPitchControl$dtTrackingSlice[1, Attack]][which.max(AttackDeltaPV)],
           aes(
               x = TargetX,
               y = TargetY
           ),
           size = 10
       )
       
   print(p1)
   
}

```

### Full game 

I'll use game 1 from Metrica Sports' release available here - https://github.com/metrica-sports/sample-data/tree/master/data/Sample_Game_1 to show some uses for this approach.

#### Team - Distributions

Let us look at the proportion of the pitch that offers a net gain in expected PV for the attacking team. This is simply checking how much of the area of the pitch offers a positive `ExpectedAttackingDeltaPV_xy` at each instant the team had possession of the ball.

```{r PositiveProportion, echo=FALSE}

dtPositiveProportion = dtPVDelta[
   AttackingTeam == Team
][,
   .SD[1], 
   list(
     Frame,
     Team
  )
][, 
   .N, 
   list(Team, AttackPositiveProportion = round(floor(100*AttackPositiveProportion)/100,2))
][
   order(Team, AttackPositiveProportion)
][, 
   N_pct := N / sum(N), 
   list(Team)
]

dtPositiveProportion = merge(
   dtPositiveProportion[, 
      list(
         AttackPositiveProportion = round(seq(
            dtPositiveProportion[, min(AttackPositiveProportion)],
            dtPositiveProportion[, max(AttackPositiveProportion)],
            0.01
         ),2)
      ),
      list(Team)
   ],
   dtPositiveProportion,
   c('Team', 'AttackPositiveProportion'),
   all.x = T
)

dtPositiveProportion[is.na(N_pct), N_pct := 0]
dtPositiveProportion[, Type := 'Outcome']

pPositiveProportion = ggplot(dtPositiveProportion) + 
   geom_col(aes(x = AttackPositiveProportion, y = N_pct, fill = Team, group = Team), position = 'dodge') + 
   # geom_point(aes(x = AttackPositiveProportion, y = N_pct, color = Team)) +
   scale_colour_discrete(name = 'Team') +
   scale_y_continuous(labels = percent, name = 'Occurrence') +
   scale_x_continuous(labels = percent, name = 'Proportion of pitch area with a positive expected change in PV for the attacking team')

print(pPositiveProportion)

dtPositiveProportion0 = dtPVDelta[
    AttackingTeam == Team
][,
  .SD[1], 
  list(
      Frame, 
      Team
  )
][, 
  .N, 
  list(AttackingTeam, Team, AttackPositiveProportionEq0 = AttackPositiveProportion == 0)
][, N_pct := N / sum(N), Team]

dtPositiveProportion0 = dtPositiveProportion0[AttackPositiveProportionEq0 == T]

```

- Most of the time there is a very small part of the pitch, if at all, that offers a positive net expected delta PV for the attacking team. 
- 30% to 40% of the time there is less than 1% of the pitch which offers a positive `ExpectedAttackingDeltaPV_xy` for both the teams. It is exactly 0 in `r dtPositiveProportion0[AttackingTeam == 'H', round(100*N_pct)]`% when the home team has the ball and `r dtPositiveProportion0[AttackingTeam == 'A', round(100*N_pct)]`% when the away team has the ball. A value of 0% means the team in possession of the ball has no options on the pitch to pass to where they are expected to increase their chances of scoring by enough to negate the chance of conceding and have to pass it to lower possession value part of the pitch. This is very important because a number of times a pass is played to retain possession and not necessarily increase the chance of scoring and the typical way PV is applied would give these passes a negative score which is unfair. We will see how we can right this injustice later in the post.
- There is almost never a situation where more than 15% of the area of the pitch offers a positive `ExpectedAttackingDeltaPV_xy` for the attacking team.
- The away team usually has options over a bigger area of the pitch than the home team.

Let us look at the values of the `ExpectedAttackingDeltaPV_xy` itself. 

If the team were to randomly pass to any point on the pitch, at each instant of the game, what delta PV could they expect?

```{r AllEPV, echo=FALSE}

dtPV = dtPVDelta[
   AttackingTeam == Team
][,
  list(
     AttackDeltaPV = max(AttackDeltaPV)
  ), 
  list(
     Frame, 
     Team
  )
][, 
  .N, 
  list(Team, AttackDeltaPV = round(floor(AttackDeltaPV*100)/100,2))
][
   order(Team, AttackDeltaPV)
][, 
  N_pct := N / sum(N), 
  list(Team)
]

dtPV = merge(
   dtPV[, 
      list(
         AttackDeltaPV = round(seq(
            dtPV[, min(AttackDeltaPV)],
            dtPV[, max(AttackDeltaPV)],
            0.01
         ),2)
      ),
      list(Team)
   ],
   dtPV,
   c('Team','AttackDeltaPV'),
   all.x = T
)

dtPV[is.na(N_pct), N_pct := 0]

ggplot(dtPV) + 
   geom_col(aes(x = AttackDeltaPV, y = N_pct, fill = Team, group = Team), position = 'dodge') + 
   # geom_point(aes(x = AttackDeltaPV, y = N_pct, color = Team)) +
   scale_y_continuous(labels = percent, name = 'Occurrence') +
   scale_x_continuous(labels = percent, name = 'Expected PV gain from random pass')

```

- From the earlier histogram, we saw most of the pitch usually offers a negative expected delta PV so it isn't surprising that this distribution is completely in the negative. What this means is that a random pass is more likely to help the defending team than an attacking team.

If we had a model to predict probabilities of passing to areas on the pitch that would have been nice but we don't. Instead, we'll look at the maximum `ExpectedAttackingDeltaPV_xy` at any instant as that number is more indicative of the best option to pass for the attacking team at any instant.

```{r PositiveEPV, echo=FALSE}

dtMaxPV = dtPVDelta[
   AttackingTeam == Team
][,
  list(
     AttackMaxDeltaPV = max(AttackMaxDeltaPV)
  ), 
  list(
     Frame, 
     Team
  )
][, 
  .N, 
  list(Team, AttackMaxDeltaPV = round(floor(AttackMaxDeltaPV*100)/100,2))
][
   order(Team, AttackMaxDeltaPV)
][, 
  N_pct := N / sum(N), 
  list(Team)
]

dtMaxPV = merge(
   dtMaxPV[, 
      list(
         AttackMaxDeltaPV = round(seq(
            dtMaxPV[, min(AttackMaxDeltaPV)],
            dtMaxPV[, max(AttackMaxDeltaPV)],
            0.01
         ),2)
      ),
      list(Team)
   ],
   dtMaxPV,
   c('Team','AttackMaxDeltaPV'),
   all.x = T
)

dtMaxPV[is.na(N_pct), N_pct := 0]
dtMaxPV[, Facet := 'Outcome']

pMaxPV = ggplot() + 
  geom_col(
     data = copy(dtMaxPV)[, Facet := 'Intent'],
     aes(x = AttackMaxDeltaPV, y = N_pct, fill = Team, group = Team), 
     position = 'dodge'
    ) + 
  scale_y_continuous(labels = percent, name = 'Occurrence') +
  scale_x_continuous(labels = percent, name = 'Max expected PV gain') 


print(pMaxPV)

```

Most of the time, the best option offers an `ExpectedAttackingDeltaPV_xy` between -1% and 2% for both teams:

```{r PositiveEPVLow, echo=FALSE}

kable(
  dtMaxPV[AttackMaxDeltaPV >= -0.01 & AttackMaxDeltaPV <= 0.02, list(HighAttackMaxDeltaPVIntent_pct = paste0(100 * round(sum(N_pct),2), '%')), Team],
  format = 'html'
)

```

The proportion of time above 2% is -

```{r PositiveEPVGT1, echo=FALSE}

(
  kable(
    dtMaxPV[AttackMaxDeltaPV >= -0.01 & AttackMaxDeltaPV > 0.02, list(LowAttackMaxDeltaPVIntent_pct = paste0(100 * round(sum(N_pct),2), '%')), Team],
    format = 'html'
  )
)

```

While the gain in PV might be large if some of these passes are successful, when you balance them out for the probability of those passes being unsuccessful, then the team in possession doesn't usually have a chance to attempt an action which offers a high probability large gain in PV.

#### Team - observations in time

```{r PositiveEPVPlayerTimeline, echo=FALSE, warning=F, message=F}

ggplot(
   dtPVDelta[
      AttackingTeam == Team, 
      list(AttackMaxDeltaPV = max(AttackMaxDeltaPV)), 
      list(Frame, Team)
   ]
) + 
   geom_point(aes(x = Frame, y = AttackMaxDeltaPV, color = Team)) + 
   facet_wrap(~Team, ncol = 1) +
   scale_y_continuous(labels = percent)

```

- Most of the high value expected delta PV for the attacking team, for either of the teams, is concentrated in time, which means they are just multiple frames from a much fewer number of instances. For the most part the teams operate in a very low expected reward sort of situation.

- You can see some patterns across the game, for instance the home team had a couple of very good chances to progress the ball towards the start of the game and had other chances through the game as well, while the away team had many good chances to progress the ball towards the end of the game but not much during the earlier part of the game. 

#### Team - observations in space

The location of the highest expected delta PV at each instant during the sample of frames looks like as below.

```{r PitchTrend, echo=FALSE}

dtPitchTrend = dtPVDelta[
  AttackingTeam == Team
][, 
  .SD[1], 
  list(Frame)
]

dtPitchTrend = dtPitchTrend[,
  .N, 
  list(Team, AttackMaxDeltaPVX, AttackMaxDeltaPVY)
]

dtPitchTrend[,
  N_pct := N / sum(N),
  list(Team)
]

dtPitchTrend = merge(
  dtPitchTrend,
  data.table(
    expand.grid(
      Team = dtPitchTrend[, unique(Team)],
      AttackMaxDeltaPVX = seq(-nXSpan/2, nXSpan/2,1),
      AttackMaxDeltaPVY = seq(-nYSpan/2, nYSpan/2,1)
    )
  ),
  c('Team','AttackMaxDeltaPVX','AttackMaxDeltaPVY'),
  all = T
)

dtPitchTrend[
  is.na(N),
  N := 0
]

dtPitchTrend[, N_pct := N / sum(N), list(Team)]

pPitchTrend = ggplot() +
  geom_pitch(cLineColour = '#CCCCCC', cPitchColour = 'transparent') +
  geom_jitter(
    data = dtPitchTrend[N_pct != 0][, list(V1 = 1:N), list(AttackMaxDeltaPVX, AttackMaxDeltaPVY, Team)],
    aes(
      x = AttackMaxDeltaPVX, y = AttackMaxDeltaPVY,
      # size = N_pct
    ), 
    size = 0.2, 
    width = 0.5,
    height = 0.5
    # color = 'black', 
    # fill = 'transparent', 
    # shape = 21
  ) +
  # scale_size_continuous(name = '% occurrence', labels = percent) +
  facet_wrap(~Team) + 
  theme_pitch()

    
print(pPitchTrend)


```

- The home team creates a lot more opportunities to progress the ball through the central areas in their own half compared to the away team that relies more heavily on opportunities wider areas. Wider areas are usually much more popular as a target though.
- If you look at the area in the defensive halves, note how the away team more often presents the best opportunity towards the left, whereas the home team has better options more often on the right side deeper in their own half, and more often on the left side more advanced in their own half.

```{r OriginPVTrend, echo=FALSE}

if ( F ) {
      
   ggplot(dtPVDelta[AttackingTeam == Team][, .SD[1], list(Frame)]) +
       geom_point(aes(x = OriginPV, y = AttackMaxDeltaPV)) +
       facet_wrap(~Team) + 
       coord_fixed()
   
}
    
```

```{r DistancePVTrend, echo=FALSE}

if ( F ) {
    
  ggplot(
    dtPVDelta[AttackingTeam == Team,.SD[1],Frame][,
      list(
        TargetDistance = (
          ( ( AttackMaxDeltaPVX - BallX ) ^ 2 ) + ( ( AttackMaxDeltaPVX - BallY ) ^ 2 )
        ) ^ 0.5,
        AttackMaxDeltaPV
      )
    ]
  ) +
    geom_point(
      aes(
        x = AttackMaxDeltaPV,
        y = TargetDistance
      )
    )
  
}

```

### Instances of high positive expected delta PV

Let's see what sort of potential passes show up if we filter for the maximum `ExpectedAttackingDeltaPV_xy` value at any frame > AttackDeltaPVThreshold. Again, these are potential passes that _could_ have been played and not necessarily the actual pass that was played at the time. There may also have been more than one such pass at any frame but we will pick only the one with the maximum `ExpectedAttackingDeltaPV_xy` value. It's also likely that during the course of the play, a similar kind of pass continued to remain the optimal choice and you would therefore see it multiple times. We can figure out a way to isolate unique passes and I can keep track of other high value passes even if they aren't the optimal but for now this is all we have.

```{r OriginTarget, echo=FALSE}

if ( T ) {

  dtOriginTarget = dtPVDelta[
    (AttackMaxDeltaPV) > AttackDeltaPVThreshold
  ][
    AttackingTeam == Team
  ][
    order(Frame)
  ][
    # c(T,diff(Frame) > 100)
  ][,
    .SD[1],
    Frame
  ]
  
  dtOriginTarget[, Facet := 'Outcome']
  dtOriginTarget[, AttackMaxDeltaPVX := AttackMaxDeltaPVX + ( ( runif(.N) - 0.5 ) / 2 )]
  dtOriginTarget[, AttackMaxDeltaPVY := AttackMaxDeltaPVY + ( ( runif(.N) - 0.5 ) / 2 )]
  
  pOriginTarget = ggplot() +
      geom_pitch(cLineColour = '#CCCCCC', cPitchColour = 'transparent') +
      geom_point(
          data = dtOriginTarget,
          aes(
              x = AttackMaxDeltaPVX,
              y = AttackMaxDeltaPVY
          )
      ) + 
      geom_segment(
        data = dtOriginTarget,
          aes(
              x = BallX,
              y = BallY,
              xend = AttackMaxDeltaPVX,
              yend = AttackMaxDeltaPVY
          ),
          alpha = 0.25
      ) + 
      facet_wrap(~Team) +
      theme_pitch()
      
  print(pOriginTarget)

}

```

- Lots of diagonal balls from deep in the defensive half to the wings.
- Lots of good opportunities to cross from the deep left for the away team. 
- The home team has opportunities from all sorts of places to put the ball in the box. 
- The away team has quite a few of these high `ExpectedAttackingDeltaPV_xy` passes targeted towards the centre of the box whereas the home team has them spread all over the box.

## Adjusting for passing ability

A lot of the high positive expected delta PV passes are quite long passes or at the edges of the pitch. Long passes are likely to fetch more PV because it usually gets you much closer to the goal from where you were before. Edges of the pitch are likely more attractive because Defenders will tend to stay towards the inside of attacking players. It is also much harder to execute such passes. The risk of passing the ball out of bounds, or not being able to pass exactly to the point a player wants to is much higher for these passes than it would be for less rewarding  passes. Until now we were looking at an outcome based `ExpectedAttackingDeltaPV_xy` but if we now switch it to an intention based `ExpectedAttackingDeltaPV_xy` then we would need to incorporate these risks in the reward we assign to an action.

To incorporate that, I add some noise to the pass end location as a function of the length of the pass. What this noise basically does is that it assumes that a pass targeted at a particular location x,y could go anywhere in the neighbourhood of x,y depending on how far x,y is from the pass origin location. The longer the pass, the more the magnitude of the noise. For passes towards the edges of the pitch, the probability that a ball is passed out of bound is considered as a turnover with the throw in being taken from the closest part of the pitch to the out of bound location. The noise is spread as a two dimensional gaussian around the target location being aimed at with the spread of the gaussian being a function of the distance of the attempt pass.

There are things you can nitpick on as being too simplistic but again this is about presenting the concept. I don't have access to the kind of data required to merit building a more robust model so I'm not even going to try.

Here is how the numbers change with the updated `ExpectedAttackingDeltaPV_xy`, which we will call `IntentExpectedAttackingDeltaPV_xy`.

```{r PositiveProportionIntent, echo=FALSE}

dtPositiveProportion2 = dtPVDelta[
   AttackingTeam == Team
][,
   .SD[1], 
   list(
     Frame, 
     Team
  )
][, 
   .N, 
   list(Team, AttackPositiveProportionIntent = round(floor(100*AttackPositiveProportionIntent)/100,2))
][
   order(Team, AttackPositiveProportionIntent)
][, 
   N_pct := N / sum(N), 
   list(Team)
]

dtPositiveProportion2 = merge(
   dtPositiveProportion2[, 
      list(
         AttackPositiveProportionIntent = round(seq(
            dtPositiveProportion2[, min(AttackPositiveProportionIntent)],
            dtPositiveProportion2[, max(AttackPositiveProportionIntent)],
            0.01
         ),2)
      ),
      list(Team)
   ],
   dtPositiveProportion2,
   c('Team','AttackPositiveProportionIntent'),
   all.x = T
)

setnames(
  dtPositiveProportion2,
  'AttackPositiveProportionIntent',
  'AttackPositiveProportion'
)

dtPositiveProportion2[is.na(N_pct), N_pct := 0]

dtPositiveProportion = merge(
  dtPositiveProportion,
  dtPositiveProportion2,
  c('Team','AttackPositiveProportion'),
  suffixes = c('.outcome','.intent'),
  all = T
)

dtPositiveProportion[is.na(N_pct.outcome), N_pct.outcome := 0]
dtPositiveProportion[is.na(N_pct.intent), N_pct.intent := 0]
# dtPositiveProportion2[, Type := 'Intent']

pPositiveProportion = ggplot() + 
   geom_col(
      data = copy(dtPositiveProportion)[, Facet := 'Outcome'],
      aes(x = AttackPositiveProportion, y = N_pct.outcome, fill = Team, group = Team), 
      position = 'dodge'
   ) + 
   geom_col(
      data = copy(dtPositiveProportion)[, Facet := 'Intent - Outcome'],
      aes(x = AttackPositiveProportion, y = N_pct.intent - N_pct.outcome, fill = Team, group = Team), 
      position = 'dodge'
   ) + 
   geom_col(
      data = copy(dtPositiveProportion)[, Facet := 'Intent'],
      aes(x = AttackPositiveProportion, y = N_pct.intent, fill = Team, group = Team), 
      position = 'dodge'
   ) + 
   # geom_point(aes(x = AttackPositiveProportion, y = N_pct, color = Team)) +
   scale_colour_discrete(name = 'Team') +
   scale_y_continuous(labels = percent, name = 'Occurrence') +
   scale_x_continuous(labels = percent, name = 'Proportion of pitch area with a positive expected change in PV for the attacking team') +
  facet_grid(Facet~.)

print(pPositiveProportion)

```

```{r PositiveEPVIntent, echo=FALSE}

dtMaxPV2 = dtPVDelta[
   AttackingTeam == Team
][,
  list(
     AttackMaxDeltaPVIntent = max(AttackMaxDeltaPVIntent)
  ), 
  list(
     Frame, 
     Team
  )
][, 
  .N, 
  list(Team, AttackMaxDeltaPVIntent = round(floor(AttackMaxDeltaPVIntent*100)/100,2))
][
   order(Team, AttackMaxDeltaPVIntent)
][, 
  N_pct := N / sum(N), 
  list(Team)
]

dtMaxPV2 = merge(
   dtMaxPV2[, 
      list(
         AttackMaxDeltaPVIntent = round(seq(
            dtMaxPV2[, min(AttackMaxDeltaPVIntent)],
            dtMaxPV2[, max(AttackMaxDeltaPVIntent)],
            0.01
         ),2)
      ),
      list(Team)
   ],
   dtMaxPV2,
   c('Team','AttackMaxDeltaPVIntent'),
   all.x = T
)

dtMaxPV2[is.na(N_pct), N_pct := 0]
setnames(
  dtMaxPV2, 'AttackMaxDeltaPVIntent','AttackMaxDeltaPV'
)
dtMaxPV = merge(
  dtMaxPV,
  dtMaxPV2,
  c('Team','AttackMaxDeltaPV'),
  suffixes = c('.outcome','.intent'),
  all = T
)

dtMaxPV[is.na(N_pct.outcome), N_pct.outcome := 0]
dtMaxPV[is.na(N_pct.intent), N_pct.intent := 0]

pMaxPV = ggplot() + 
  geom_col(
     data = copy(dtMaxPV)[, Facet := 'Intent'],
     aes(x = AttackMaxDeltaPV, y = N_pct.intent, fill = Team, group = Team), 
     position = 'dodge'
    ) + 
  geom_col(
     data = copy(dtMaxPV)[, Facet := 'Outcome'],
     aes(x = AttackMaxDeltaPV, y = N_pct.outcome, fill = Team, group = Team), 
     position = 'dodge'
    ) + 
  geom_col(
     data = copy(dtMaxPV)[, Facet := 'Intent - Outcome'],
     aes(x = AttackMaxDeltaPV, y = N_pct.intent - N_pct.outcome, fill = Team, group = Team), 
     position = 'dodge'
    ) + 
  scale_y_continuous(labels = percent, name = 'Occurrence') +
  scale_x_continuous(labels = percent, name = 'Max expected PV gain') + 
  facet_grid(Facet~.)

print(pMaxPV)

```

```{r PitchTrendIntent, echo=FALSE}

dtPitchTrend2 = dtPVDelta[
  AttackingTeam == Team
][, 
  .SD[1], 
  list(Frame)
]

dtPitchTrend2 = dtPitchTrend2[,
  .N, 
  list(
    Team, 
    AttackMaxDeltaPVX = AttackMaxDeltaPVIntentX, 
    AttackMaxDeltaPVY = AttackMaxDeltaPVIntentY
  )
]

dtPitchTrend2[,
  N_pct := N / sum(N),
  list(Team)
]

dtPitchTrend = merge(
  dtPitchTrend2,
  dtPitchTrend,
  c('Team','AttackMaxDeltaPVX','AttackMaxDeltaPVY'),
  all = T,
  suffixes = c('.intent','.outcome')
)

dtPitchTrend[
  is.na(N_pct.outcome),
  N_pct.outcome := 0
]

dtPitchTrend[
  is.na(N_pct.intent),
  N_pct.intent := 0
]

dtPitchTrend[, IntentMinusOutcome := as.character(sign(N_pct.intent - N_pct.outcome))]
dtPitchTrend[IntentMinusOutcome == '-1', IntentMinusOutcome := '-']
dtPitchTrend[IntentMinusOutcome == '1', IntentMinusOutcome := '+']
dtPitchTrend[IntentMinusOutcome == '0', IntentMinusOutcome := '']

pPitchTrend = ggplot() +
    geom_pitch(cLineColour = '#CCCCCC', cPitchColour = 'transparent') +
    geom_jitter(
        data = dtPitchTrend[N_pct.outcome != 0][, list(V1 = 1:N.outcome, Facet = 'Outcome'), list(AttackMaxDeltaPVX, AttackMaxDeltaPVY, Team)],
        aes(
            x = AttackMaxDeltaPVX, y = AttackMaxDeltaPVY,
            # size = N_pct
        ), 
        size = 0.2,
        color = 'black', 
        width = 0.5,
        height = 0.5
        # fill = 'transparent', 
        # shape = 21
    ) +
    geom_jitter(
        data = dtPitchTrend[N_pct.intent != 0][, list(V1 = 1:N.intent, Facet = 'Intent'), list(AttackMaxDeltaPVX, AttackMaxDeltaPVY, Team)],
        aes(
            x = AttackMaxDeltaPVX, y = AttackMaxDeltaPVY,
            # size = N_pct
        ), 
        size = 0.2,
        color = 'black', 
        width = 0.5,
        height = 0.5
        # fill = 'transparent', 
        # shape = 21
    ) +
    facet_grid(Facet~Team) + 
    theme_pitch()

print(pPitchTrend)

    
```

```{r OriginTargetIntent, echo=FALSE}

dtOriginTarget = dtPVDelta[
  (AttackMaxDeltaPVIntent) > AttackDeltaPVThreshold
][
  AttackingTeam == Team
][
  order(Frame)
][
  # c(T,diff(Frame) > 100)
][,
  .SD[1],
  Frame
]

dtOriginTarget[, Facet := 'Intent']
dtOriginTarget[, AttackMaxDeltaPVX := AttackMaxDeltaPVX + ( ( runif(.N) - 0.5 ) / 2 )]
dtOriginTarget[, AttackMaxDeltaPVY := AttackMaxDeltaPVY + ( ( runif(.N) - 0.5 ) / 2 )]

pOriginTarget +
    # geom_pitch(cLineColour = '#CCCCCC', cPitchColour = 'transparent') +
    geom_point(
        data = dtOriginTarget,
        aes(
            x = AttackMaxDeltaPVIntentX,
            y = AttackMaxDeltaPVIntentY
        )
    ) + 
    geom_segment(
        data = dtOriginTarget,
        aes(
            x = BallX,
            y = BallY,
            xend = AttackMaxDeltaPVIntentX,
            yend = AttackMaxDeltaPVIntentY
        ),
        alpha = 0.25
    ) + 
    facet_grid(Facet~Team)
    
```

- The distributions don't move significantly but they do move a little bit towards the direction of lower possible gains. This makes sense, you'd expect ådding noise to reduce the optimal value.
- Note the slightly lesser instances of the model suggesting that the pass should be right at the goal mouth or even at the edge of the pitch on the wings. Because in those cases, there is a chance of the ball going out of bounds as well which would mean handing over the ball to the other team. This reduces how attractive those locations are and the optimal locations move a little inwards. How much they move inside is likely an artifact of the way the noise has been incorporated in the model though, because the locations are still clumped tightly

Here is a distribution of the distance between the Intent optimal pass location and the Outcome optimal pass location by the pass distance.

```{r DistanceChange, echo=FALSE}

dtPVDeltaChange = dtPVDelta[
        AttackingTeam == Team, 
        .SD[1], 
        Frame
    ][,
      list(
          Frame,
          Team,
          PassDistance = (
              ( ( BallX - AttackMaxDeltaPVX ) ^ 2 ) +
                  ( ( BallY - AttackMaxDeltaPVY ) ^ 2 ) 
          ) ^ 0.5,
          PassIntentDistance = (
              ( ( BallX - AttackMaxDeltaPVIntentX ) ^ 2 ) +
                  ( ( BallY - AttackMaxDeltaPVIntentY ) ^ 2 ) 
          ) ^ 0.5,
          TargetChangeDistance = (
              ( ( AttackMaxDeltaPVIntentX - AttackMaxDeltaPVX ) ^ 2 ) +
                  ( ( AttackMaxDeltaPVIntentY - AttackMaxDeltaPVY ) ^ 2 ) 
          ) ^ 0.5
      )
    ]

if ( F ) {
    
  ggplot() +
     geom_boxplot(
        data = dtPVDelta[
           AttackingTeam == Team, 
           .SD[1], 
           Frame
        ][,
           list(
              Team,
              PassDistance = (
                 ( ( BallX - AttackMaxDeltaPVX ) ^ 2 ) +
                    ( ( BallY - AttackMaxDeltaPVY ) ^ 2 ) 
              ) ^ 0.5,
              PassIntentDistance = (
                 ( ( BallX - AttackMaxDeltaPVIntentX ) ^ 2 ) +
                    ( ( BallY - AttackMaxDeltaPVIntentY ) ^ 2 ) 
              ) ^ 0.5,
              TargetChangeDistance = (
                 ( ( AttackMaxDeltaPVIntentX - AttackMaxDeltaPVX ) ^ 2 ) +
                    ( ( AttackMaxDeltaPVIntentY - AttackMaxDeltaPVY ) ^ 2 ) 
              ) ^ 0.5
           )
        ],
        aes(
           x = 10 * ( PassDistance %/% 10 ),
           # y = TargetChangeDistance,
           y = PassIntentDistance - PassDistance,
           group = paste0(Team, 10 * ( PassDistance %/% 10 )),
           color = Team
        ),
        fill = 'transparent'
     )

}

ggplot(
    dtPVDeltaChange[, 
      .N, 
      list(
          Team, 
          PassDistance = 10 * floor(PassDistance/10), 
          # PassIntentDistance = 10 * floor(PassIntentDistance/10),
          ChangeInDistance = round(PassIntentDistance - PassDistance, -1)
      )
    ][, 
      list(ChangeInDistance, N_pct = N/sum(N)), 
      list(Team, PassDistance)
    ]
) + 
    geom_tile(aes(x = PassDistance, y = ChangeInDistance, alpha = N_pct)) +
    geom_text(aes(x = PassDistance, y = ChangeInDistance, label = round(N_pct,2))) +
    facet_wrap(~Team)

```

Longer passes are more likely to be in areas with small pockets of space so the fact that we include the possibility of slightly wayward passes means the reward of _intending_ to pass to them reduces and the optimal passes tend to become shorter. It's a little odd that the longest passes aren't as compromised as the medium range passes though, and I suspect it's the goalkeeper area being tricky again. ( If I had to argue against this I'd say that we use a distance based noise function because we expect longer passes to be harder to execute and therefore The trend of longer passes seeing a more drastic change might be a self-fulfilling result. )

As an illustration -

```{r IntentIllustrationData, echo = F}

load(
   file.path(
      cRootDirectory,
      'PassingAwareness',
      'ProgressivePassingOpportunity',
      cGameName,
      'Actual',
      '4',
      'Results',
      '52293.Rdata'
   )
)

load(
   file.path(
      cRootDirectory,
      'PassingAwareness',
      'ProgressivePassingOpportunity',
      cGameName,
      'Actual',
      '4',
      'Metadata.Rdata'
   )
)

lIntentValues = fGetIntentValues(lMetadata, lPitchControl, lData)

pChangePitchControl = ggplot() +
  # geom_tile(
  #   data = lIntentValues$dtDetailsAggregated[AttackingTeam == Tag][, Facet := 'Outcome'],
  #   aes(
  #     x = TargetX,
  #     y = TargetY,
  #     fill = AttackPPCF
  #   )
  # ) +
  # geom_tile(
  #   data = lIntentValues$dtDetailsAggregated[AttackingTeam == Tag][, Facet := 'Intent'],
  #   aes(
  #     x = TargetX,
  #     y = TargetY,
  #     fill = AttackPPCFIntent
  #   )
  # ) +
  geom_tile(
    data = lIntentValues$dtDetailsAggregated[AttackingTeam == Tag][, Facet := 'Intent - Outcome'],
    aes(
      x = TargetX,
      y = TargetY,
      fill = AttackPPCFIntent - AttackPPCF
    )
  ) + geom_point(
        data = lPitchControl$dtTrackingSlice[Tag == 'B'],
        aes(x = X, y = Y),
        color = 'black',
        size = 3
    ) +
    geom_point(
        data = lPitchControl$dtTrackingSlice[Tag != 'B'],
        aes(x = X, y = Y, color = Tag)
    ) +
  scale_fill_gradient2(low = 'red', high = 'blue', mid = 'white') +
  geom_pitch(cLineColour = '#CCCCCC', cPitchColour = 'transparent') +
  facet_wrap(~Facet)

print(pChangePitchControl)

pChangePitchControl = ggplot() +
  # geom_tile(
  #   data = lIntentValues$dtDetailsAggregated[AttackingTeam == Tag][, Facet := 'Outcome'],
  #   aes(
  #     x = TargetX,
  #     y = TargetY,
  #     fill = AttackPPCF
  #   )
  # ) +
  # geom_tile(
  #   data = lIntentValues$dtDetailsAggregated[AttackingTeam == Tag][, Facet := 'Intent'],
  #   aes(
  #     x = TargetX,
  #     y = TargetY,
  #     fill = AttackPPCFIntent
  #   )
  # ) +
  geom_tile(
    data = lIntentValues$dtDetailsAggregated[AttackingTeam == Tag][
      TargetX >= -10 & TargetY > -35 & TargetY < 35
    ][, Facet := 'Intent - Outcome'],
    aes(
      x = TargetX,
      y = TargetY,
      fill = AttackPPCFIntent - AttackPPCF
    )
  ) + geom_point(
        data = lPitchControl$dtTrackingSlice[Tag == 'B'],
        aes(x = X, y = Y),
        color = 'black',
        size = 3
    ) +
    geom_point(
        data = lPitchControl$dtTrackingSlice[Tag != 'B'],
        aes(x = X, y = Y, color = Tag)
    ) +
  scale_fill_gradient2(low = 'red', high = 'blue', mid = 'white') +
  geom_pitch(cLineColour = '#CCCCCC', cPitchColour = 'transparent') +
  facet_wrap(~Facet)

print(pChangePitchControl)


pChangePV = ggplot() +
  # geom_tile(
  #   data = lIntentValues$dtDetailsAggregated[AttackingTeam == Tag][, Facet := 'Outcome'],
  #   aes(
  #     x = TargetX,
  #     y = TargetY,
  #     fill = AttackDeltaPV
  #   )
  # ) +
  # geom_tile(
  #   data = lIntentValues$dtDetailsAggregated[AttackingTeam == Tag][, Facet := 'Intent'],
  #   aes(
  #     x = TargetX,
  #     y = TargetY,
  #     fill = AttackDeltaPVIntent
  #   )
  # ) +
  geom_tile(
    data = lIntentValues$dtDetailsAggregated[AttackingTeam == Tag][
      TargetX >= -10 & TargetY > -35 & TargetY < 35
    ][, Facet := 'Intent - Outcome'],
    aes(
      x = TargetX,
      y = TargetY,
      fill = AttackDeltaPVIntent - AttackDeltaPV
    )
  ) + geom_point(
        data = lPitchControl$dtTrackingSlice[Tag == 'B'],
        aes(x = X, y = Y),
        color = 'black',
        size = 3
    ) +
    geom_point(
        data = lPitchControl$dtTrackingSlice[Tag != 'B'],
        aes(x = X, y = Y, color = Tag)
    ) +
  scale_fill_gradient2(low = 'red', high = 'blue', mid = 'white') +
  geom_pitch(cLineColour = '#CCCCCC', cPitchColour = 'transparent') +
  facet_wrap(~Facet)

print(pChangePV)

```
