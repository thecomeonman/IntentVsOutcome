---
title: "Intent vs. Outcome: adding another layer to expected possession value"
output: md_document
---

# Intent vs. Outcome: adding another layer to expected possession value

This is a thinking out loud kind of post. A bunch of basic charts and numbers are here which should be enough to give an idea of what I'm proposing. I want to think about this some more, which is usually a long and slow process because life gets in the way, before doing a version with nice looking vizes, etc. + also get feedback and comments from you guys.

## Introduction

http://www.lukebornn.com/papers/fernandez_sloan_2019.pdf proposes a probabilistic possession value based on combining the possession value ( PV ) of the part of the pitch from a PV model, the probability of the ball being controlled in the part of the pitch from a pitch control model, the pass difficulty from a pass probability model, and the probability of the ball being played to that part of the pitch from an action likelihood model. These numbers can then be used to infer passing tendencies, awareness, positioning, and many other things.

Pitch control, pass probability, and action likelihood are _outcome_ based models. Pitch control tells you the probability of controlling the ball if it were played to that part of the pitch. Pass probability tells you the probability of successfully making a pass to a particular point on the pitch and is likely based on historic pass data which means it is outcome based. Action likelihood is also probably based on historic match data and is also probably outcome based. An additional aspect we need to evaluate things like player decision making is _intent_. That's what the rest of the post is about.

We'll exclude action likelihood and only look at the output just from the possession value and the pitch control models. This lets us evaluate any opportunity across the pitch without prejudice for what players tend to do in that situation.

If you're familiar with pitch control and possession value, you can probably just glance at the Glossary section and then skip straight to the Intent vs. Outcome section.

```{r setup, include=FALSE}

rm(list = ls())

library(data.table)
library(ggplot2)
library(scales)
library(CodaBonito)
library(knitr)
library(akima)

knitr::opts_chunk$set(
   echo = F,
   message = F,
   warning = F,
   fig.width = 12,
   fig.height = 6
)

theme_set(theme_bw(12))

```

```{r parameters, echo=FALSE}

cRootDirectory = '~/Desktop/Data/Projects/Personal'

nXSpan = 120
nYSpan = 80
nUpperLimitSpeed = 5 * 120 / 105
nMaxPassLength = nXSpan * 2/3

cGameName = 'Sample_Game_1'

dtPlayerLabels = rbind(
   data.table(
      Player = paste0(c(''), 2:12),
      Label = c(
         'RCB',
         'LCB',
         'LB',
         'RW',
         'LCM',
         'RB',
         'LW',
         'CF',
         'CAM',
         'GK',
         'RCM'
      )
   ),
   data.table(
      Player = paste0(c(''), 15:25),
      Label = c(
         'RCB',
         'CB',
         'RWB',
         'CM',
         'RCM',
         'LCB',
         'LCM',
         'LWB',
         'LF',
         'RF',
         'GK'
      )
   )
)

dtPlayerLabels[,
   Label := factor(
      Label,
      levels = c(
         'GK',
         'RCB','CB','LCB',
         'RB','LB','RWB','LWB',
         'CDM',
         'RCM','CM','LCM',
         'RW','RCAM','CAM','LCAM','LW',
         'RF','CF','LF'
      ),
      ordered = T
   )
]

AttackDeltaPVThreshold = 0.02
PlayerDeltaPVThreshold = 0.01

DataFrequency_hz = 25
```

```{r functions, echo=FALSE}

source(file.path(cRootDirectory, '/AnalysingFootballData/IntentvsOutcome.R'))
```

```{r data, echo=FALSE}

lData = fParseTrackingDataBothTeams(
  cRootPath = file.path(cRootDirectory,'/sample-data/data/'),
  cGameName = cGameName,
  nXSpan = nXSpan,
  nYSpan = nYSpan,
  xMaxBB = 1,
  yMaxBB = 1,
  nUpperLimitSpeed = nUpperLimitSpeed
)

dtPVDelta = readRDS(file.path(cRootDirectory, 'IntentVsOutcome/PVDelta.Rdata'))

dtPVDelta[, Team := Tag]
dtPVDelta[Tag == 'A', BallX := -BallX]
dtPVDelta[Tag == 'A', BallY := -BallY]
dtPVDelta[Tag == 'A', PlayerMaxDeltaPVX := -PlayerMaxDeltaPVX]
dtPVDelta[Tag == 'A', PlayerMaxDeltaPVY := -PlayerMaxDeltaPVY]
dtPVDelta[Tag == 'A', AttackMaxDeltaPVX := -AttackMaxDeltaPVX]
dtPVDelta[Tag == 'A', AttackMaxDeltaPVY := -AttackMaxDeltaPVY]
dtPVDelta[Tag == 'A', PlayerMaxDeltaPVIntentX := -PlayerMaxDeltaPVIntentX]
dtPVDelta[Tag == 'A', PlayerMaxDeltaPVIntentY := -PlayerMaxDeltaPVIntentY]
dtPVDelta[Tag == 'A', AttackMaxDeltaPVIntentX := -AttackMaxDeltaPVIntentX]
dtPVDelta[Tag == 'A', AttackMaxDeltaPVIntentY := -AttackMaxDeltaPVIntentY]

```

## EPV Methodology

### Pitch Control

Pitch control tells you the probability of a team and its players controlling the ball at various parts of the pitch if the ball were to be passed there. This is done for each instant of the game and changes based on the positions of the players and their movement. 

I use Spearman's model but you could probably swap it out for any other model too.

### Possession Value

The probability of scoring at the end of a play / in the next some moves / in the next some seconds once the team has a ball in a particular part of the pitch.

I've used the PV grid at https://raw.githubusercontent.com/Friends-of-Tracking-Data-FoTD/LaurieOnTracking/master/EPV_grid.csv which looks like this for a team attacking left to right -

```{r PVParms, echo=FALSE}

if ( F ) {
   
   nCompoundingFactor = 1
   nNumeratorFactor = 0.9
   
   ggplot() + 
      geom_line(
         data = data.table(
            Distance = seq(
               0,
               ceiling(
                  ( 
                     ( 120 ^ 2 ) +
                     ( 40 ^ 2 )
                  ) ^ ( 0.5 * nCompoundingFactor )
               ),
               1
            )
         )[,
            PV := nNumeratorFactor / ( Distance + 1 )
         ],
         aes(
            x = Distance,
            y = PV
         )
      ) +
      labs(
         x = 'Distance from goal',
         y = 'Possession value'
      ) +
      scale_y_continuous(labels = percent)
   
} else if ( T ) {
   
   dtPitchGrid = expand.grid(
      x = seq(-nXSpan/2, nXSpan/2, 1),
      y = seq(-nYSpan/2, nYSpan/2, 1)
   )
   setDT(dtPitchGrid)
   
   dtPitchGrid[,
      PV := fGetPV(
         x,
         y
      )
   ]
   
   p1 = ggplot(dtPitchGrid) +
      geom_tile(
        aes(x = x, y = y, fill = PV)
       ) +
       geom_pitch(cPitchColour = 'transparent', cLineColour = '#CCCCCC') +
       scale_fill_continuous(low = 'white', high = 'red', limits = c(0,1), labels = percent) +
       theme_pitch()
   
   print(p1)
   
}

```

The possession value sharply climbs close to 50% near the opposition goal but is quite low for most of the pitch.

We can rotate the pitch halfway around and get the PV values for the respective part of the pitch for the opposition since that team is attacking right to left.

You should be able to swap it out for another PV model, if you so prefer.

### Combining Pitch Control and Possession Value - Glossary

You should be able to combine these to evaluate what passing options offer progress to the team in possession.

- The team in possession already has a certain PV depending on where they have the ball: `AttackOriginPV`
- The defending team is equally at risk of conceding a goal from that position, so `DefenseOriginPV = -AttackOriginPV`
- Assuming it is possible to pass to every point on the pitch, `(x,y)`, the PV for each target location can be calculated for both the teams, `AttackTargetPV_xy` and `DefenseTargetPV_xy`
- At every point on the pitch, `(x,y)`, the attacking team has a probability of keeping control of the ball, `AttackProbabilty_xy`, and therefore the defending team's probability is `DefenseProbabilty_xy = 1 - AttackProbabilty_xy`
- At every point, `(x,y)`, we can estimate an expected PV for playing a pass there:
   - For the attacking team, `AttackTargetEPV_xy = ( AttackProbabilty_xy * AttackTargetPV_xy ) - ( DefenseProbabilty_xy * DefenseTargetPV_xy )`
   - For the defending team, which is the same as the above formula with the attacking / defending terms exchanged, `DefenseTargetEPV_xy = ( DefenseProbabilty_xy * DefenseTargetPV_xy ) - ( AttackProbabilty_xy * AttackTargetPV_xy )`
- The expected change in PV by passing the ball from the current position to a target position can be calculated as the difference of the above terms from the PV of the starting position:
    - For the attacking team, `AttackEPVAdded_xy = AttackTargetEPV_xy - AttackOriginPV`
    - For the defending team, `DefenseEPVAdded_xy = DefenseTargetEPV_xy - DefenseOriginPV`
- At any point, the optimal action for the attacking team to perform should be to move the ball to a point which offers the highest `AttackTargetEPV_xy`. We'll call the EPV added at that point `AttackMaxEPVAdded`. This value may not always be positive.

A positive `AttackEPVAdded_xy` implies that passing the ball to that point on the pitch is likely to increase the chance of scoring even after considering the risk of conceding the ball. A negative value implies that passing the ball to that point is likely going to decrease the chance of scoring.

```{r PVBreakEven, echo=FALSE}

# Given we know the PV of each part of the pitch for both teams, and we know that the probability of controlling the ball for both teams must add up to 1 in each part of the pitch, we can calculate the minimum value `AttackTargetEPV_xy` must be in each part of the pitch for it to compensate for `DefenseExpectedingDeltaPV_xy`, and therefore we can also calculate the minimum value `AttackProbabilty_xy` should be for `AttackTargetEPV_xy` to attain the necessary value. Think of this value for `AttackProbabilty_xy` as a kind of breakeven probability. This is what those probabilities look like -
  
if ( F ) {
    
  dtPitchGrid = merge(dtPitchGrid,dtPitchGrid[, list(x = -x, y = -y, OppositionPV = PV)], c('x','y'))
  
  dtPitchGrid[, BreakevenProbability := OppositionPV / ( PV + OppositionPV )]
  
  p2 = ggplot(dtPitchGrid) +
     geom_tile(
       aes(x = x, y = y, fill = BreakevenProbability)
      ) +
      geom_pitch(cPitchColour = 'transparent', cLineColour = '#CCCCCC') +
      scale_fill_continuous(low = 'white', high = 'red', limits = c(0,1)) +
      theme_pitch()
  
  print(p2)
  
}

# Note how the breakeven probabilities are very low close to the opposition goal, because in that area the PV is very high for the attacking team compared to the PV for the defending team. In fact right at the goal mouth, the breakeven probability is `r dtPitchGrid[x == nXSpan/2 & y == 0, BreakevenProbability]`. This part of the pitch is a little hard to work with though because goalkeepers are also modelled as outfield players in this pitch control model whereas in reality they would actually exert far greater control than the model gives them credit for because they can use their hands, grab the ball in the air, dive, etc. which the other players cannot do. The pitch control models don't model shots either, it models passes, so the idea of 'passing to the goal' is also a little odd. We will see later that this situation occurs in very few frames though so for now we will pretend this isn't a problem and carry on. 

```

I ignore the possibility of passes that travel more than 2/3 the length of the pitch. Only Ederson can make such passes. We consider the area that is within a radius of 2/3 length of the pitch at any point of time and ignore everything outside of it.

We can expect `DefenseEPVAdded_xy` to be positive very often, since `DefenseOriginPV` is a negative value so the more interesting thing to analyse would be `AttackEPVAdded_xy`.

### Combining Pitch Control and Possession Value - Example

I use one frame to give an example of these calculations.

```{r IllustrationData, echo=FALSE}

load(
   file.path(
      cRootDirectory,
      'IntentVsOutcome',
      'ProgressivePassingOpportunity',
      cGameName,
      'Actual',
      '2',
      'Results',
      '67776.Rdata'
   )
)

load(
   file.path(
      cRootDirectory,
      'IntentVsOutcome',
      'ProgressivePassingOpportunity',
      cGameName,
      'Actual',
      '2',
      'Metadata.Rdata'
   )
)

```

Here is what the pitch control looks like in a random frame. I exclude players that are offside so the two players from the blue team in the offside position have zero contribution to pitch control.

```{r PitchControlIllustation, echo=FALSE}

ggplot() + 
    geom_tile(
        data = lPitchControl$dtDetails,
        aes(x = TargetX, y = TargetY, fill = AttackProbability)
    ) +
    geom_point(
        data = lPitchControl$dtTrackingSlice[Tag == 'B'],
        aes(x = X, y = Y),
        color = 'black',
        size = 3
    ) +
    geom_point(
        data = lPitchControl$dtTrackingSlice[Tag != 'B'],
        aes(x = X, y = Y),
        color = 'black',
        size = 2
    ) +
    geom_point(
        data = lPitchControl$dtTrackingSlice[Tag != 'B'],
        aes(x = X, y = Y),
        color = 'black',
        size = 2
    ) +
    geom_point(
        data = lPitchControl$dtTrackingSlice[Tag != 'B'],
        aes(x = X, y = Y, color = Tag)
    ) +
    scale_color_discrete(name = 'Team') +
    geom_pitch(cPitchColour = 'transparent', cLineColour = '#CCCCCC') +
    scale_fill_gradient2(midpoint = 0.5, low = 'red', high = 'blue', labels = percent, name = 'Attack team\ncontrol prob.') +
    theme_pitch()
    
```

This is what the pitch looks like in terms of `AttackEPVAdded_xy`.

```{r EPVIllustationTeam, echo=FALSE}

dtDetails = merge(
  lPitchControl$dtDetails[, list(SNO, Frame, TargetX, TargetY)],
  lPitchControl$dtTrackingSlice[
      Player == 0, 
      list(AttackingTeam, Frame, BallX = X, BallY = Y)
  ],
  'Frame'
)

dtDetails = merge(
  dtDetails,
  lPitchControl$dtTrackingSlice[, 
      list(Frame, Player, Tag, TeamInPossession, PlayerInPossession)
  ],
  'Frame',
  allow.cartesian = T
)

dtDetails = merge(
  dtDetails,
  lPitchControl$dtTrackingSliceVectorised[, 
    list(SNO, Player, PlayerPPCF)
  ],
  c('SNO','Player')
)

if ( nrow(dtDetails) == 0 ) {
  stop()
}


if ( lMetadata$cTeam == 'H' ) {
  dtDetails[, OriginPV := fGetPV(BallX, BallY)]
} else {
  dtDetails[, OriginPV := fGetPV(-BallX, -BallY)]
}

dtDetails[AttackingTeam != Tag, OriginPV := -OriginPV]

dtDetails[Tag == 'H', TeamTargetPV := fGetPV(TargetX, TargetY)]
dtDetails[Tag == 'A', TeamTargetPV := fGetPV(-TargetX, -TargetY)]
dtDetails[Tag == 'H', OppositionTargetPV := fGetPV(-TargetX, -TargetY)]
dtDetails[Tag == 'A', OppositionTargetPV := fGetPV(TargetX, TargetY)]

dtDetailsAggregated = dtDetails[, 
  list(
    AttackPPCF = sum(PlayerPPCF)
  ),
  list(
    Frame,
    Tag,
    TargetX,
    TargetY,
    BallX,
    BallY,
    TeamTargetPV,
    OppositionTargetPV,
    OriginPV
  )
]

dtDetailsAggregated[, 
  AttackDeltaPV := (
    ( AttackPPCF * TeamTargetPV ) -
    ( ( 1 - AttackPPCF ) * ( OppositionTargetPV ) )
  ) - (
    1 * OriginPV
  )
]

    
p1 = ggplot() + 
    geom_tile(
        data = dtDetailsAggregated[lPitchControl$dtTrackingSlice[1, AttackingTeam] == Tag],
        aes(x = TargetX, y = TargetY, fill = AttackDeltaPV)
    ) +
    geom_point(
        data = lPitchControl$dtTrackingSlice[Tag == 'B'],
        aes(x = X, y = Y),
        color = 'black',
        size = 3
    ) +
    geom_point(
        data = lPitchControl$dtTrackingSlice[Tag != 'B'],
        aes(x = X, y = Y, color = Tag)
    ) +
    geom_pitch(cPitchColour = 'transparent', cLineColour = '#CCCCCC') +
    scale_fill_gradient2(midpoint = 0, high = 'blue', low = 'red', labels = percent, name = 'EPV added') +
    scale_color_discrete(name = 'Team') +
    theme_pitch()
    
print(p1)

```

There is some territory in the middle of the pitch where passing the ball is expected to return a positive `AttackEPVAdded_xy`. And then there is an area near the opposition goal, which has a larger `AttackEPVAdded_xy` than the middle of the pitch. This area lights up because 1, the goalkeeper isn't given extra powers to control the ball in the pitch control model which is not the case in real life since keepers can catch the ball with their hands, dive on it, etc. and 2, pitch control is only reflective of passes, not shots. As a result of this inconsistency, the logic above would suggest that in this situation the optimal action for the team in possession, the blue team, should be to pass the ball all the way to the goal and hope that the small chance of another player from the same team controlling the ball pays off for the high reward you'd get from successfully controlling the ball at that location.

Don't want to raise your hopes so specifying that what I'll be proposing here doesn't directly address this goalkeeper area problem but does help reduce the problem.

```{r EPVIllustationTeamOptimal, echo=FALSE}

if ( F ) {
      
   p1 = p1 + 
      geom_tile(
           data = dtDetailsAggregated[Tag == lPitchControl$dtTrackingSlice[1, Attack]][which.max(AttackDeltaPV)],
           aes(
               x = TargetX,
               y = TargetY
           ),
           size = 10
       )
       
   print(p1)
   
}

```

### Combining Pitch Control and Possession Value

I use game 1 from Metrica Sports' release available here - https://github.com/metrica-sports/sample-data/tree/master/data/Sample_Game_1. The findings WRT to the home and away team obviously don't carry over to all games but the more general inferences probably do.

Let us look at the proportion of the pitch that offers a positive `AttackEPVAdded_xy` at each instant the team had possession of the ball.

```{r PositiveProportion, echo=FALSE}

dtPositiveProportion = dtPVDelta[
   AttackingTeam == Team
][,
   .SD[1], 
   list(
     Frame,
     Team
  )
][, 
   .N, 
   list(Team, AttackPositiveProportion = round(floor(100*AttackPositiveProportion)/100,2))
][
   order(Team, AttackPositiveProportion)
][, 
   N_pct := N / sum(N), 
   list(Team)
]

dtPositiveProportion = merge(
   dtPositiveProportion[, 
      list(
         AttackPositiveProportion = round(seq(
            dtPositiveProportion[, min(AttackPositiveProportion)],
            dtPositiveProportion[, max(AttackPositiveProportion)],
            0.01
         ),2)
      ),
      list(Team)
   ],
   dtPositiveProportion,
   c('Team', 'AttackPositiveProportion'),
   all.x = T
)

dtPositiveProportion[is.na(N_pct), N_pct := 0]
dtPositiveProportion[, Type := 'Outcome']

pPositiveProportion = ggplot(dtPositiveProportion) + 
   geom_col(aes(x = AttackPositiveProportion, y = N_pct, fill = Team, group = Team), position = 'dodge') + 
   # geom_point(aes(x = AttackPositiveProportion, y = N_pct, color = Team)) +
   scale_colour_discrete(name = 'Team') +
   scale_y_continuous(labels = percent, name = 'Occurrence') +
   scale_x_continuous(labels = percent, name = 'Proportion of pitch area with a positive expected change in PV for the attacking team')

print(pPositiveProportion)

dtPositiveProportion0 = dtPVDelta[
    AttackingTeam == Team
][,
  .SD[1], 
  list(
      Frame, 
      Team
  )
][, 
  .N, 
  list(AttackingTeam, Team, AttackPositiveProportionEq0 = AttackPositiveProportion == 0)
][, N_pct := N / sum(N), Team]

dtPositiveProportion0 = dtPositiveProportion0[AttackPositiveProportionEq0 == T]

```

- Most of the time there is a very small part of the pitch, if at all, that offers a positive EPV added for the attacking team. This means there is a very small part of the pitch that the attacking team can pass to and expect their possession value to go up when you factor the risk of conceding the ball.
- 30% to 40% of the time there is less than 1% of the area of the pitch which offers a positive `AttackEPVAdded_xy` for both the teams. It is exactly 0% of the area in `r dtPositiveProportion0[AttackingTeam == 'H', round(100*N_pct)]`% for the home team and `r dtPositiveProportion0[AttackingTeam == 'A', round(100*N_pct)]`% for the away team has the ball. A value of 0% for `AttackEPVAdded_xy` means the team in possession of the ball has no options on the pitch to pass to where they are expected to increase their chances of scoring by enough to negate the chance of conceding. This is very important because a number of times a pass is played just to retain possession and not necessarily increase the chance of scoring and the typical way PV is applied would give these passes a negative score which is unfair because the situation is not taken into account.
- There is almost never a situation where more than 15% of the area of the pitch offers a positive `AttackEPVAdded_xy` for the attacking team.
- The away team usually has options over a bigger area of the pitch than the home team.

Let us look at the values of the `AttackEPVAdded_xy` itself. 

If the team were to randomly pass to any point on the pitch, at each instant of the game, what `AttackEPVAdded_xy` could they expect? This would be the same as averaging the `AttackEPVAdded_xy` values over the entire pitch and would look like -

```{r AllEPV, echo=FALSE}

dtPV = dtPVDelta[
   AttackingTeam == Team
][,
  list(
     AttackDeltaPV = max(AttackDeltaPV)
  ), 
  list(
     Frame, 
     Team
  )
][, 
  .N, 
  list(Team, AttackDeltaPV = round(floor(AttackDeltaPV*100)/100,2))
][
   order(Team, AttackDeltaPV)
][, 
  N_pct := N / sum(N), 
  list(Team)
]

dtPV = merge(
   dtPV[, 
      list(
         AttackDeltaPV = round(seq(
            dtPV[, min(AttackDeltaPV)],
            dtPV[, max(AttackDeltaPV)],
            0.01
         ),2)
      ),
      list(Team)
   ],
   dtPV,
   c('Team','AttackDeltaPV'),
   all.x = T
)

dtPV[is.na(N_pct), N_pct := 0]

ggplot(dtPV) + 
   geom_col(aes(x = AttackDeltaPV, y = N_pct, fill = Team, group = Team), position = 'dodge') + 
   # geom_point(aes(x = AttackDeltaPV, y = N_pct, color = Team)) +
   scale_y_continuous(labels = percent, name = 'Occurrence') +
   scale_x_continuous(labels = percent, name = 'Average expected delta PV over the whole of the pitch')

```

- From the earlier histogram, we saw most of the pitch usually offers a negative EPV added so it isn't surprising that this distribution is completely in the negative. What this means is that a random pass is more likely to aid the defending team than the attacking team.

If we instead look at the best option the team has at any instant, `AttackMaxEPVAdded` -

```{r PositiveEPV, echo=FALSE}

dtMaxPV = dtPVDelta[
   AttackingTeam == Team
][,
  list(
     AttackMaxDeltaPV = max(AttackMaxDeltaPV)
  ), 
  list(
     Frame, 
     Team
  )
][, 
  .N, 
  list(Team, AttackMaxDeltaPV = round(floor(AttackMaxDeltaPV*100)/100,2))
][
   order(Team, AttackMaxDeltaPV)
][, 
  N_pct := N / sum(N), 
  list(Team)
]

dtMaxPV = merge(
   dtMaxPV[, 
      list(
         AttackMaxDeltaPV = round(seq(
            dtMaxPV[, min(AttackMaxDeltaPV)],
            dtMaxPV[, max(AttackMaxDeltaPV)],
            0.01
         ),2)
      ),
      list(Team)
   ],
   dtMaxPV,
   c('Team','AttackMaxDeltaPV'),
   all.x = T
)

dtMaxPV[is.na(N_pct), N_pct := 0]
dtMaxPV[, Facet := 'Outcome']

pMaxPV = ggplot() + 
  geom_col(
     data = copy(dtMaxPV)[, Facet := 'Intent'],
     aes(x = AttackMaxDeltaPV, y = N_pct, fill = Team, group = Team), 
     position = 'dodge'
    ) + 
  scale_y_continuous(labels = percent, name = 'Occurrence') +
  scale_x_continuous(labels = percent, name = 'Max expected PV gain') 


print(pMaxPV)

```

- Most of the time, the best option offers an `AttackMaxEPVAdded` between -1% and 2% for both teams. Specifically the amount of time is -

```{r PositiveEPVLow, echo=FALSE}

kable(
  dtMaxPV[AttackMaxDeltaPV >= -0.01 & AttackMaxDeltaPV <= 0.02, list(HighAttackMaxDeltaPVIntent_pct = paste0(100 * round(sum(N_pct),2), '%')), Team],
  format = 'html'
)

```

The proportion of time `AttackMaxEPVAdded` is above `r AttackDeltaPVThreshold * 100`% -

```{r PositiveEPVGT1, echo=FALSE}

(
  kable(
    dtMaxPV[AttackMaxDeltaPV >= -0.01 & AttackMaxDeltaPV > AttackDeltaPVThreshold, list(LowAttackMaxDeltaPVIntent_pct = paste0(100 * round(sum(N_pct),2), '%')), Team],
    format = 'html'
  )
)

```

How about where these options are available?

The location offering `AttackMaxEPVAdded` at each instant during the sample of frames looks like as below. Both teams have almost equal possession so don't worry too much about normalising this chart.

```{r PitchTrend, echo=FALSE}

dtPitchTrend = dtPVDelta[
  AttackingTeam == Team
][, 
  .SD[1], 
  list(Frame)
]

dtPitchTrend = dtPitchTrend[,
  .N, 
  list(Team, AttackMaxDeltaPVX, AttackMaxDeltaPVY)
]

dtPitchTrend[,
  N_pct := N / sum(N),
  list(Team)
]

dtPitchTrend = merge(
  dtPitchTrend,
  data.table(
    expand.grid(
      Team = dtPitchTrend[, unique(Team)],
      AttackMaxDeltaPVX = seq(-nXSpan/2, nXSpan/2,1),
      AttackMaxDeltaPVY = seq(-nYSpan/2, nYSpan/2,1)
    )
  ),
  c('Team','AttackMaxDeltaPVX','AttackMaxDeltaPVY'),
  all = T
)

dtPitchTrend[
  is.na(N),
  N := 0
]

dtPitchTrend[, N_pct := N / sum(N), list(Team)]

pPitchTrend = ggplot() +
  geom_pitch(cLineColour = '#CCCCCC', cPitchColour = 'transparent') +
  geom_jitter(
    data = dtPitchTrend[N_pct != 0][, list(V1 = 1:N), list(AttackMaxDeltaPVX, AttackMaxDeltaPVY, Team)],
    aes(
      x = AttackMaxDeltaPVX, y = AttackMaxDeltaPVY,
      # size = N_pct
    ), 
    size = 0.2, 
    width = 0.5,
    height = 0.5
    # color = 'black', 
    # fill = 'transparent', 
    # shape = 21
  ) +
  # scale_size_continuous(name = '% occurrence', labels = percent) +
  facet_wrap(~Team) + 
  theme_pitch()

    
print(pPitchTrend)


```

- The home team often has the best opportunity to make progress through the central areas in their own half, the away team uses this area much lesser. 
- In the defensive halves, the away team more often presents the best opportunity towards the left side. The home team has better options more often on the right side deeper in their own half, and more often on the left side more advanced in their own half.
- The away team relies on wider areas as the best opportunity to progress much earlier on on the pitch compared to the home team.
- The best options to pass into the box are quite concentrated in front of the goal mouth for the away team. The home team has a few sports around which they offer an option often.

We haven't looked at the distribution of the ball positions in these frames so we shouldn't draw detailed conclusions from just these figures. That analysis is not necessary for the point of this post anyway so we'll skip it. This is just warming you up to how we can look at things.

```{r OriginPVTrend, echo=FALSE}

if ( F ) {
      
   ggplot(dtPVDelta[AttackingTeam == Team][, .SD[1], list(Frame)]) +
       geom_point(aes(x = OriginPV, y = AttackMaxDeltaPV)) +
       facet_wrap(~Team) + 
       coord_fixed()
   
}
    
```

```{r DistancePVTrend, echo=FALSE}

if ( F ) {
    
  ggplot(
    dtPVDelta[AttackingTeam == Team,.SD[1],Frame][,
      list(
        TargetDistance = (
          ( ( AttackMaxDeltaPVX - BallX ) ^ 2 ) + ( ( AttackMaxDeltaPVX - BallY ) ^ 2 )
        ) ^ 0.5,
        AttackMaxDeltaPV
      )
    ]
  ) +
    geom_point(
      aes(
        x = AttackMaxDeltaPV,
        y = TargetDistance
      )
    )
  
}

```

If we filter only the frames where `AttackMaxEPVAdded` > `r AttackDeltaPVThreshold`, these are the frames which had at least one pass which allowed the team to make substantial progress towards scoring. Note that these are potential passes that _could_ have been played and not necessarily the actual pass that was played at the time. There may also have been more than one such pass at any frame but we will pick only the one with the `AttackMaxEPVAdded` value. It's also likely that during the course of the play, a similar kind of pass continued to remain the optimal choice for consecutive frames in the sample and you would therefore see it multiple times.

```{r OriginTarget, echo=FALSE}

if ( T ) {

  dtOriginTarget = dtPVDelta[
    (AttackMaxDeltaPV) > AttackDeltaPVThreshold
  ][
    AttackingTeam == Team
  ][
    order(Frame)
  ][
    # c(T,diff(Frame) > 100)
  ][,
    .SD[1],
    Frame
  ]
  
  dtOriginTarget[, Facet := 'Outcome']
  dtOriginTarget[, AttackMaxDeltaPVX := AttackMaxDeltaPVX + ( ( runif(.N) - 0.5 ) / 2 )]
  dtOriginTarget[, AttackMaxDeltaPVY := AttackMaxDeltaPVY + ( ( runif(.N) - 0.5 ) / 2 )]
  
  pOriginTarget = ggplot() +
      geom_pitch(cLineColour = '#CCCCCC', cPitchColour = 'transparent') +
      geom_point(
          data = dtOriginTarget,
          aes(
              x = AttackMaxDeltaPVX,
              y = AttackMaxDeltaPVY
          )
      ) + 
      geom_segment(
        data = dtOriginTarget,
          aes(
              x = BallX,
              y = BallY,
              xend = AttackMaxDeltaPVX,
              yend = AttackMaxDeltaPVY
          ),
          alpha = 0.25
      ) + 
      facet_wrap(~Team) +
      theme_pitch()
      
  print(pOriginTarget)

}

```

- Lots of diagonal balls from deep in the defensive half to the wings.
- Lots of good opportunities to cross from the deep left for the away team. The home team also has slightly higher opportunities to put the ball in the box being created from the left wing but they have other options as well from other parts of the pitch.

## Intent vs. Outcome

**This is point of this post.** Thanks for staying with me. All the stuff above was to get you comfortable with the setting which hopefully you are by now.

Note how most high value `AttackEPVAdded_xy` passes are long passes, often aimed at the edges of the pitch. Note how the optimal targets are also concentrated around the edges of the pitch. Long passes are likely to fetch more PV because it usually gets you much closer to the goal from where the ball was before. Edges of the pitch are more attractive because defenders will tend to stay towards the insides of the pitch leaving one side less for a defender to impact the pitch control of a wide positioned player from the attacking team. This is expected.

The reason I started writing is because while these are rewarding passes if they actually happen, it is also much harder to execute such passes. In the EPV paper, there is a pass probability component which is a logistic regression model but if it is like most other pass probability models then it is also modelling the probability of accurately passing to a particular point on the pitch and the training data is probably based on historic pass data which are again outcomes. I think there is room to improve this.

The risk of passing the ball out of bounds, or not being able to pass accurately to the point with the maximum EPV added is much higher for passes close to the sidelines, long passes, and so on compared to easier passes to someone in the middle of the pitch or to someone closer to the player in possession. Until now we were looking at an outcome based `AttackMaxEPVAdded` i.e. the EPV the team could expect to gain if the ball reached a particular `(x.y)` but if we switch to an intention based `AttackEPVAdded_xy`, i.e. the EPV the team could expect to gain if the ball was attempted to be passed to a particular `(x.y)` then we would need to incorporate the risks of inaccuracy in passing. There are other factors that could also cause inaccuracy such as pressure on the ball, the passer's body orientation, etc. but for now we will keep it simple and consider only the length of the pass and the target location. Note that the term inaccuracy is typically used to describe whether a pass was successfully received by a teammate but in this post it is being used to describe whether a pass intended for a particular location actually reaches that location or goes somewhere else.

```{r IntentIllustrationPlot1, echo = F}

dtExamplePass = data.table(
  TargetX = c(10,40,20),
  TargetY = c(-10,30,-39)
)[,
  c('BallX','BallY') := list(-20,-20)
][,
  Label := c('Safe','Risky because\nof length','Risky because close\nto out of bounds')
]

pPassRiskIllustration = ggplot(dtExamplePass) +
  geom_pitch(cLineColour = '#CCCCCC', cPitchColour = 'transparent') +
  geom_segment(
    aes(
      x = BallX,
      y = BallY,
      xend = TargetX,
      yend = TargetY
    )
  ) +
  geom_point(
    aes(
      x = TargetX,
      y = TargetY
    )
  ) +
  theme_pitch()

print(
  pPassRiskIllustration +
  geom_text(
    aes(
      x = TargetX,
      y = TargetY,
      label = Label,
      hjust = 0
    ),
    nudge_x = 1
  ) 
)

```

To model this inaccuracy - let us assume that a pass intended for a particular location x,y could actually go anywhere in the neighbourhood of x,y depending on how far x,y is from the pass origin location. To simulate this, I take the intended pass target location and calculate possible actual pass target location by adding some noise to the intended coordinates. For actual targets that go out of bounds the appropriate corner, goal kick, or throw in location is calculated and considered as the next event and the PV calculation is done accordingly.

```{r IntentIllustrationPlot2, echo = F}

print(
  pPassRiskIllustration +
    geom_polygon(
      data = dtExamplePass[, 
          list(
              TargetPolyX = cos(2*pi*seq(0,100,1)/100),
              TargetPolyY = sin(2*pi*seq(0,100,1)/100),
              Radius = 0.1 * ( ( ((TargetX - BallX) ^ 2) + ((TargetY - BallY) ^ 2) ) ^ 0.5 )
          ), 
          list(TargetX, TargetY)
      ][,
        TargetPolyX := TargetPolyX * Radius
      ][,
        TargetPolyY := TargetPolyY * Radius
      ],
      aes(
        x = TargetX + TargetPolyX,
        y = TargetY + TargetPolyY,
        group = paste(TargetX, TargetY)
      ),
      fill = 'transparent',
      color = 'black'
    )
)

```

For each intended target location, the probability of the ball landing in any of the actual target location in the neighbourhood of the intended target location is modelled as a two dimensional gaussian centred around the intended target location. The standard deviation of the gaussian is a linear function of the intended pass length such that 99% of the pass attempts land within a radius of ( 10% of the intended pass length ) from the intended pass target location. For computational convenience, we ignore points outside this radius.

```{r IntentIllustrationPlot3, echo = F}

print(
  
  pPassRiskIllustration +
    geom_polygon(
      data = dtExamplePass[, 
          list(
              TargetPolyX = cos(2*pi*seq(0,100,1)/100),
              TargetPolyY = sin(2*pi*seq(0,100,1)/100),
              Radius = 0.1 * ( ( ((TargetX - BallX) ^ 2) + ((TargetY - BallY) ^ 2) ) ^ 0.5 )
          ), 
          list(TargetX, TargetY)
      ][,
        list(
          Radius = 0:3 * (Radius/3)
        ),
        list(TargetX, TargetY, TargetPolyX, TargetPolyY)
      ][,
        TargetPolyX := TargetPolyX * Radius
      ][,
        TargetPolyY := TargetPolyY * Radius
      ],
      aes(
        x = TargetX + TargetPolyX,
        y = TargetY + TargetPolyY,
        group = paste(TargetX, TargetY, Radius)
      ),
      fill = 'black',
      alpha = 0.2,
      color = 'black'
    )
  
)

```

Now that we have these probabilities, we can calculate a new set of pitch control and expected possession values for each intended target location by aggregating the outcome based pitch control and expected possession values of all its actual target locations weighed by the the probability of that actual target location.

This is not the same as just having a pass distance feature in the pass probability logistic regression model. We are redefining pitch control and possession value altogether by differentiating what they mean for a receiver and what they mean for a passer.

### Combining Pitch Control, Possession Value, and Intent - Example

Another one frame example to give you an idea of how this manifests. From here on, the charts marked outcome are the same set of numbers from the charts in the earlier section and the charts marked intent are the new set of numbers.

```{r IntentIllustrationData, echo = F}

load(
   file.path(
      cRootDirectory,
      'IntentVsOutcome',
      'ProgressivePassingOpportunity',
      cGameName,
      'Actual',
      '1',
      'Results',
      '5627.Rdata'
   )
)

load(
   file.path(
      cRootDirectory,
      'IntentVsOutcome',
      'ProgressivePassingOpportunity',
      cGameName,
      'Actual',
      '1',
      'Metadata.Rdata'
   )
)

lRealisticValues = fGetIntentValues(lMetadata, lPitchControl, lData)

```

```{r IntentIllustrationComparison, echo = F}

pChangePitchControl = ggplot() +
  geom_tile(
    data = lRealisticValues$dtDetailsAggregated[AttackingTeam == Tag][, Facet := 'Outcome'],
    aes(
      x = TargetX,
      y = TargetY,
      fill = AttackPPCF
    )
  ) +
  geom_tile(
    data = lRealisticValues$dtDetailsAggregated[AttackingTeam == Tag][, Facet := 'Intent'],
    aes(
      x = TargetX,
      y = TargetY,
      fill = AttackPPCFIntent
    )
  ) +
  # geom_tile(
  #   data = lRealisticValues$dtDetailsAggregated[AttackingTeam == Tag][, Facet := 'Intent - Outcome'],
  #   aes(
  #     x = TargetX,
  #     y = TargetY,
  #     fill = AttackPPCFIntent - AttackPPCF
  #   )
  # ) + 
  geom_point(
      data = lPitchControl$dtTrackingSlice[Tag == 'B'],
      aes(x = X, y = Y),
      color = 'black',
      size = 3
  ) +
  geom_point(
      data = lPitchControl$dtTrackingSlice[Tag != 'B'],
      aes(x = X, y = Y, color = Tag)
  ) +
  scale_color_discrete(name = 'Team') +
  scale_fill_gradient2(low = 'red', high = 'blue', mid = 'white', midpoint = 0.5, labels = percent, name = 'Attack team\ncontrol prob.') +
  geom_pitch(cLineColour = '#CCCCCC', cPitchColour = 'transparent') +
  facet_wrap(~Facet) +
  theme_pitch()

print(pChangePitchControl)

```

- The intent based versions are a little less crisp in the areas where both teams have similar probabilities of controlling the ball. The parts of the pitch around the edges of the blue team dominated areas are also a little faded out.

Here is what the delta in control probability between the two looks like. Note the change in the colour scale -

```{r IntentIllustrationDifferencePC, echo = F}

pChangePitchControl = ggplot() +
  # geom_tile(
  #   data = lRealisticValues$dtDetailsAggregated[AttackingTeam == Tag][, Facet := 'Outcome'],
  #   aes(
  #     x = TargetX,
  #     y = TargetY,
  #     fill = AttackPPCF
  #   )
  # ) +
  # geom_tile(
  #   data = lRealisticValues$dtDetailsAggregated[AttackingTeam == Tag][, Facet := 'Intent'],
  #   aes(
  #     x = TargetX,
  #     y = TargetY,
  #     fill = AttackPPCFIntent
  #   )
  # ) +
  geom_tile(
    data = lRealisticValues$dtDetailsAggregated[AttackingTeam == Tag][, Facet := 'Intent - Outcome'],
    aes(
      x = TargetX,
      y = TargetY,
      fill = AttackPPCFIntent - AttackPPCF
    )
  ) + geom_point(
        data = lPitchControl$dtTrackingSlice[Tag == 'B'],
        aes(x = X, y = Y),
        color = 'black',
        size = 3
    ) +
    geom_point(
        data = lPitchControl$dtTrackingSlice[Tag != 'B'],
        aes(x = X, y = Y, color = Tag)
    ) +
  scale_color_discrete(name = 'Team') +
  scale_fill_gradient2(low = 'red', high = 'blue', mid = 'white', midpoint = 0, labels = percent, name = 'Intent - outcome\nattack team\ncontrol prob.') +
  geom_pitch(cLineColour = '#CCCCCC', cPitchColour = 'transparent') +
  # facet_wrap(~Facet) + 
  theme_pitch()

print(pChangePitchControl)

```

- A drop of up to ~35% in pitch control in some parts close to the edge. 
- Lesser magnitude drops in the middle of the pitch. 

Let's exclude the edges and see how much the central areas change by. Again note the change in the colour scale -

```{r IntentIllustrationDifferencePCFocused, echo = F}

pChangePitchControl = ggplot() +
  # geom_tile(
  #   data = lRealisticValues$dtDetailsAggregated[AttackingTeam == Tag][, Facet := 'Outcome'],
  #   aes(
  #     x = TargetX,
  #     y = TargetY,
  #     fill = AttackPPCF
  #   )
  # ) +
  # geom_tile(
  #   data = lRealisticValues$dtDetailsAggregated[AttackingTeam == Tag][, Facet := 'Intent'],
  #   aes(
  #     x = TargetX,
  #     y = TargetY,
  #     fill = AttackPPCFIntent
  #   )
  # ) +
  geom_tile(
    data = lRealisticValues$dtDetailsAggregated[AttackingTeam == Tag][
      abs(TargetX) < 55 & abs(TargetY) < 35
    ][, Facet := 'Intent - Outcome'],
    aes(
      x = TargetX,
      y = TargetY,
      fill = AttackPPCFIntent - AttackPPCF
    )
  ) + geom_point(
        data = lPitchControl$dtTrackingSlice[Tag == 'B'],
        aes(x = X, y = Y),
        color = 'black',
        size = 3
    ) +
    geom_point(
        data = lPitchControl$dtTrackingSlice[Tag != 'B'],
        aes(x = X, y = Y, color = Tag)
    ) +
  scale_color_discrete(name = 'Team') +
  scale_fill_gradient2(low = 'red', high = 'blue', mid = 'white', midpoint = 0, labels = percent, name = 'Intent - outcome\nattack team\ncontrol prob.') +
  geom_pitch(cLineColour = '#CCCCCC', cPitchColour = 'transparent') +
  # facet_wrap(~Facet) +
  theme_pitch()

print(pChangePitchControl)

```

- Drops of +-3% can be seen in the areas away from the areas strongly domainated by either team.

What difference does that translate to in terms of the `AttackEPVAdded_xy`

```{r IntentIllustrationComparisonPV, echo = F}

pChangePV = ggplot() +
  geom_tile(
    data = lRealisticValues$dtDetailsAggregated[AttackingTeam == Tag][, Facet := 'Outcome'],
    aes(
      x = TargetX,
      y = TargetY,
      fill = AttackDeltaPV
    )
  ) +
  geom_tile(
    data = lRealisticValues$dtDetailsAggregated[AttackingTeam == Tag][, Facet := 'Intent'],
    aes(
      x = TargetX,
      y = TargetY,
      fill = AttackDeltaPVIntent
    )
  ) +
  # geom_tile(
  #   data = lRealisticValues$dtDetailsAggregated[AttackingTeam == Tag][
  #     TargetX >= -10 & TargetY > -35 & TargetY < 35
  #   ][, Facet := 'Intent - Outcome'],
  #   aes(
  #     x = TargetX,
  #     y = TargetY,
  #     fill = AttackDeltaPVIntent - AttackDeltaPV
  #   )
  # ) + 
  geom_point(
      data = lPitchControl$dtTrackingSlice[Tag == 'B'],
      aes(x = X, y = Y),
      color = 'black',
      size = 3
  ) +
  geom_point(
      data = lPitchControl$dtTrackingSlice[Tag != 'B'],
      aes(x = X, y = Y, color = Tag)
  ) +
  scale_color_discrete(name = 'Team') +
  scale_fill_gradient2(low = 'red', high = 'blue', mid = 'white', midpoint = 0, labels = percent, name = 'EPV added') +
  geom_pitch(cLineColour = '#CCCCCC', cPitchColour = 'transparent') +
  facet_wrap(~Facet) +
  theme_pitch()

print(pChangePV)

```

Okay not very easy to spot differences. The delta in the central area looks like -

```{r IntentIllustrationComparisonPVFocused, echo = F}

pChangePV = ggplot() +
  # geom_tile(
  #   data = lRealisticValues$dtDetailsAggregated[AttackingTeam == Tag][, Facet := 'Outcome'],
  #   aes(
  #     x = TargetX,
  #     y = TargetY,
  #     fill = AttackDeltaPV
  #   )
  # ) +
  # geom_tile(
  #   data = lRealisticValues$dtDetailsAggregated[AttackingTeam == Tag][, Facet := 'Intent'],
  #   aes(
  #     x = TargetX,
  #     y = TargetY,
  #     fill = AttackDeltaPVIntent
  #   )
  # ) +
  geom_tile(
    data = lRealisticValues$dtDetailsAggregated[AttackingTeam == Tag][
      abs(TargetX) < 55 & abs(TargetY) < 35
    ][, Facet := 'Intent - Outcome'],
    aes(
      x = TargetX,
      y = TargetY,
      fill = AttackDeltaPVIntent - AttackDeltaPV
    )
  ) + geom_point(
        data = lPitchControl$dtTrackingSlice[Tag == 'B'],
        aes(x = X, y = Y),
        color = 'black',
        size = 3
    ) +
    geom_point(
        data = lPitchControl$dtTrackingSlice[Tag != 'B'],
        aes(x = X, y = Y, color = Tag)
    ) +

  scale_color_discrete(name = 'Team') +
  scale_fill_gradient2(low = 'red', high = 'blue', mid = 'white', midpoint = 0, labels = percent, name = 'Intent - outcome\nEPV added') +  
  geom_pitch(cLineColour = '#CCCCCC', cPitchColour = 'transparent') +
  # facet_wrap(~Facet) +
  theme_pitch()

print(pChangePV)

```

The optimal intent based pass target location is quite far from the optimal outcome based pass target location. Optimal location marked with a + -

```{r IntentIllustrationComparisonOptimal, echo = F}

pChangePV = ggplot() +
  geom_tile(
    data = lRealisticValues$dtDetailsAggregated[AttackingTeam == Tag][, Facet := 'Outcome'],
    aes(
      x = TargetX,
      y = TargetY,
      fill = AttackDeltaPV
    )
  ) +
  geom_tile(
    data = lRealisticValues$dtDetailsAggregated[AttackingTeam == Tag][, Facet := 'Intent'],
    aes(
      x = TargetX,
      y = TargetY,
      fill = AttackDeltaPVIntent
    )
  ) +
  # geom_tile(
  #   data = lRealisticValues$dtDetailsAggregated[AttackingTeam == Tag][
  #     TargetX >= -10 & TargetY > -35 & TargetY < 35
  #   ][, Facet := 'Intent - Outcome'],
  #   aes(
  #     x = TargetX,
  #     y = TargetY,
  #     fill = AttackDeltaPVIntent - AttackDeltaPV
  #   )
  # ) + 
  geom_point(
      data = lPitchControl$dtTrackingSlice[Tag == 'B'],
      aes(x = X, y = Y),
      color = 'black',
      size = 3
  ) +
  geom_point(
      data = lPitchControl$dtTrackingSlice[Tag != 'B'],
      aes(x = X, y = Y, color = Tag)
  ) +
  geom_point(
      data = dtPVDelta[Frame == lPitchControl$dtTrackingSlice[1,Frame]][1, list(AttackMaxDeltaPVX, AttackMaxDeltaPVY, Facet = 'Outcome')],
      aes(x = AttackMaxDeltaPVX, y = AttackMaxDeltaPVY),
      color = 'black',
      # fill = 'transparent',
      size = 2,
      shape = 3
  ) +
  geom_point(
      data = dtPVDelta[Frame == lPitchControl$dtTrackingSlice[1,Frame]][1, list(AttackMaxDeltaPVIntentX, AttackMaxDeltaPVIntentY,Facet = 'Intent')],
      aes(x = AttackMaxDeltaPVIntentX, y = AttackMaxDeltaPVIntentY),
      color = 'black',
      # fill = 'transparent',
      size = 2,
      shape = 3
  ) +
  scale_color_discrete(name = 'Team') +
  scale_fill_gradient2(low = 'red', high = 'blue', mid = 'white', midpoint = 0, labels = percent, name = 'EPV added') +
  geom_pitch(cLineColour = '#CCCCCC', cPitchColour = 'transparent') +
  facet_wrap(~Facet) +
  theme_pitch()

print(pChangePV)

```

The target is still on the right wing, but near the centre line as per the intent model whereas the outcome based optimal location is around a quarter of the length of the pitch farther ahead and much closer to the edge of the pitch.

### Combining Pitch Control, Possession Value, and Intent

Before we look at the distributions from earlier again, here is a quick comparison of the change -

```{r IntentOutcomeScatter, echo=FALSE}

ggplot(dtPVDelta) + 
  geom_point(aes(x = AttackMaxDeltaPV, y = AttackMaxDeltaPVIntent - AttackMaxDeltaPV)) +
  facet_wrap(~Team) +
  # coord_fixed() +
  scale_y_continuous(label = percent, name = 'Intent based - outcome based max EPV added') +
  scale_x_continuous(label = percent, name = 'Outcome based max EPV added')

```

- Most high outcome based `AttackMaxEPVAdded` values take a hit when you compare them to the corresponding intent based `AttackMaxEPVAdded`. This is expected since a lot of these were near the edges of the pitch or very long passes.

Here are the rest of the distributions with the comparisons.

```{r PositiveProportionIntent, echo=FALSE}

dtPositiveProportion2 = dtPVDelta[
   AttackingTeam == Team
][,
   .SD[1], 
   list(
     Frame, 
     Team
  )
][, 
   .N, 
   list(Team, AttackPositiveProportionIntent = round(floor(100*AttackPositiveProportionIntent)/100,2))
][
   order(Team, AttackPositiveProportionIntent)
][, 
   N_pct := N / sum(N), 
   list(Team)
]

dtPositiveProportion2 = merge(
   dtPositiveProportion2[, 
      list(
         AttackPositiveProportionIntent = round(seq(
            dtPositiveProportion2[, min(AttackPositiveProportionIntent)],
            dtPositiveProportion2[, max(AttackPositiveProportionIntent)],
            0.01
         ),2)
      ),
      list(Team)
   ],
   dtPositiveProportion2,
   c('Team','AttackPositiveProportionIntent'),
   all.x = T
)

setnames(
  dtPositiveProportion2,
  'AttackPositiveProportionIntent',
  'AttackPositiveProportion'
)

dtPositiveProportion2[is.na(N_pct), N_pct := 0]

dtPositiveProportion = merge(
  dtPositiveProportion,
  dtPositiveProportion2,
  c('Team','AttackPositiveProportion'),
  suffixes = c('.outcome','.intent'),
  all = T
)

dtPositiveProportion[is.na(N_pct.outcome), N_pct.outcome := 0]
dtPositiveProportion[is.na(N_pct.intent), N_pct.intent := 0]
# dtPositiveProportion2[, Type := 'Intent']

pPositiveProportion = ggplot() + 
   geom_col(
      data = copy(dtPositiveProportion)[, Facet := 'Outcome'],
      aes(x = AttackPositiveProportion, y = N_pct.outcome, fill = Team, group = Team), 
      position = 'dodge'
   ) + 
   geom_col(
      data = copy(dtPositiveProportion)[, Facet := 'Intent - Outcome'],
      aes(x = AttackPositiveProportion, y = N_pct.intent - N_pct.outcome, fill = Team, group = Team), 
      position = 'dodge'
   ) + 
   geom_col(
      data = copy(dtPositiveProportion)[, Facet := 'Intent'],
      aes(x = AttackPositiveProportion, y = N_pct.intent, fill = Team, group = Team), 
      position = 'dodge'
   ) + 
   # geom_point(aes(x = AttackPositiveProportion, y = N_pct, color = Team)) +
   scale_colour_discrete(name = 'Team') +
   scale_y_continuous(labels = percent, name = 'Occurrence') +
   scale_x_continuous(labels = percent, name = 'Proportion of pitch area with a positive expected change in PV for the attacking team') +
  facet_grid(Facet~.)

print(pPositiveProportion)

```

- You can see a shift in the distribution towards the left, from having larger parts of the pitch having a positive `AttackEPVAdded_xy` in the outcome version of the model to smaller parts of the pitch in the intent version of the model.

The other distributions also change in a similar manner -

```{r PositiveEPVIntent, echo=FALSE}

dtMaxPV2 = dtPVDelta[
   AttackingTeam == Team
][,
  list(
     AttackMaxDeltaPVIntent = max(AttackMaxDeltaPVIntent)
  ), 
  list(
     Frame, 
     Team
  )
][, 
  .N, 
  list(Team, AttackMaxDeltaPVIntent = round(floor(AttackMaxDeltaPVIntent*100)/100,2))
][
   order(Team, AttackMaxDeltaPVIntent)
][, 
  N_pct := N / sum(N), 
  list(Team)
]

dtMaxPV2 = merge(
   dtMaxPV2[, 
      list(
         AttackMaxDeltaPVIntent = round(seq(
            dtMaxPV2[, min(AttackMaxDeltaPVIntent)],
            dtMaxPV2[, max(AttackMaxDeltaPVIntent)],
            0.01
         ),2)
      ),
      list(Team)
   ],
   dtMaxPV2,
   c('Team','AttackMaxDeltaPVIntent'),
   all.x = T
)

dtMaxPV2[is.na(N_pct), N_pct := 0]
setnames(
  dtMaxPV2, 'AttackMaxDeltaPVIntent','AttackMaxDeltaPV'
)
dtMaxPV = merge(
  dtMaxPV,
  dtMaxPV2,
  c('Team','AttackMaxDeltaPV'),
  suffixes = c('.outcome','.intent'),
  all = T
)

dtMaxPV[is.na(N_pct.outcome), N_pct.outcome := 0]
dtMaxPV[is.na(N_pct.intent), N_pct.intent := 0]

pMaxPV = ggplot() + 
  geom_col(
     data = copy(dtMaxPV)[, Facet := 'Intent'],
     aes(x = AttackMaxDeltaPV, y = N_pct.intent, fill = Team, group = Team), 
     position = 'dodge'
    ) + 
  geom_col(
     data = copy(dtMaxPV)[, Facet := 'Outcome'],
     aes(x = AttackMaxDeltaPV, y = N_pct.outcome, fill = Team, group = Team), 
     position = 'dodge'
    ) + 
  geom_col(
     data = copy(dtMaxPV)[, Facet := 'Intent - Outcome'],
     aes(x = AttackMaxDeltaPV, y = N_pct.intent - N_pct.outcome, fill = Team, group = Team), 
     position = 'dodge'
    ) + 
  scale_y_continuous(labels = percent, name = 'Occurrence') +
  scale_x_continuous(labels = percent, name = 'Max expected PV gain') + 
  facet_grid(Facet~.)

print(pMaxPV)

```

```{r PitchTrendIntent, echo=FALSE}

dtPitchTrend2 = dtPVDelta[
  AttackingTeam == Team
][, 
  .SD[1], 
  list(Frame)
]

dtPitchTrend2 = dtPitchTrend2[,
  .N, 
  list(
    Team, 
    AttackMaxDeltaPVX = AttackMaxDeltaPVIntentX, 
    AttackMaxDeltaPVY = AttackMaxDeltaPVIntentY
  )
]

dtPitchTrend2[,
  N_pct := N / sum(N),
  list(Team)
]

dtPitchTrend = merge(
  dtPitchTrend2,
  dtPitchTrend,
  c('Team','AttackMaxDeltaPVX','AttackMaxDeltaPVY'),
  all = T,
  suffixes = c('.intent','.outcome')
)

dtPitchTrend[
  is.na(N_pct.outcome),
  N_pct.outcome := 0
]

dtPitchTrend[
  is.na(N_pct.intent),
  N_pct.intent := 0
]

dtPitchTrend[, IntentMinusOutcome := as.character(sign(N_pct.intent - N_pct.outcome))]
dtPitchTrend[IntentMinusOutcome == '-1', IntentMinusOutcome := '-']
dtPitchTrend[IntentMinusOutcome == '1', IntentMinusOutcome := '+']
dtPitchTrend[IntentMinusOutcome == '0', IntentMinusOutcome := '']

pPitchTrend = ggplot() +
    geom_pitch(cLineColour = '#CCCCCC', cPitchColour = 'transparent') +
    geom_jitter(
        data = dtPitchTrend[N_pct.outcome != 0][, list(V1 = 1:N.outcome, Facet = 'Outcome'), list(AttackMaxDeltaPVX, AttackMaxDeltaPVY, Team)],
        aes(
            x = AttackMaxDeltaPVX, y = AttackMaxDeltaPVY,
            # size = N_pct
        ), 
        size = 0.2,
        color = 'black', 
        width = 0.5,
        height = 0.5
        # fill = 'transparent', 
        # shape = 21
    ) +
    geom_jitter(
        data = dtPitchTrend[N_pct.intent != 0][, list(V1 = 1:N.intent, Facet = 'Intent'), list(AttackMaxDeltaPVX, AttackMaxDeltaPVY, Team)],
        aes(
            x = AttackMaxDeltaPVX, y = AttackMaxDeltaPVY,
            # size = N_pct
        ), 
        size = 0.2,
        color = 'black', 
        width = 0.5,
        height = 0.5
        # fill = 'transparent', 
        # shape = 21
    ) +
    facet_grid(Facet~Team) + 
    theme_pitch()

print(pPitchTrend)

    
```

```{r OriginTargetIntent, echo=FALSE}

dtOriginTarget = dtPVDelta[
  (AttackMaxDeltaPVIntent) > AttackDeltaPVThreshold
][
  AttackingTeam == Team
][
  order(Frame)
][
  # c(T,diff(Frame) > 100)
][,
  .SD[1],
  Frame
]

dtOriginTarget[, Facet := 'Intent']
dtOriginTarget[, AttackMaxDeltaPVX := AttackMaxDeltaPVX + ( ( runif(.N) - 0.5 ) / 2 )]
dtOriginTarget[, AttackMaxDeltaPVY := AttackMaxDeltaPVY + ( ( runif(.N) - 0.5 ) / 2 )]

pOriginTarget +
    # geom_pitch(cLineColour = '#CCCCCC', cPitchColour = 'transparent') +
    geom_point(
        data = dtOriginTarget,
        aes(
            x = AttackMaxDeltaPVIntentX,
            y = AttackMaxDeltaPVIntentY
        )
    ) + 
    geom_segment(
        data = dtOriginTarget,
        aes(
            x = BallX,
            y = BallY,
            xend = AttackMaxDeltaPVIntentX,
            yend = AttackMaxDeltaPVIntentY
        ),
        alpha = 0.25
    ) + 
    facet_grid(Facet~Team)
    
```

- The distributions move towards lower possible `AttackMaxEPVAdded` values. This makes sense, you'd expect dding noise would reduce the reward possible from the optimal choice.
- Note how the intent based model suggests fewer passes right at the goal mouth or at the edge of the pitch on the wings and has much fewer opportunities for high `AttackMaxEPVAdded` passes. These were the kind of passes where there is a chance of the ball going out of bounds as well or not being hit exactly at the target which get penalised in the intent model but not in the outcome model.

Here is a distribution of the difference in distance between the optimal intent based pass distance and the optimal outcome based pass distance bucketed by the optimal outcome based pass distance.

```{r DistanceChange, echo=FALSE}

dtPVDeltaChange = dtPVDelta[
    AttackingTeam == Team, 
    .SD[1], 
    Frame
][,
  list(
      Frame,
      Team,
      PassDistance = (
          ( ( BallX - AttackMaxDeltaPVX ) ^ 2 ) +
              ( ( BallY - AttackMaxDeltaPVY ) ^ 2 ) 
      ) ^ 0.5,
      PassIntentDistance = (
          ( ( BallX - AttackMaxDeltaPVIntentX ) ^ 2 ) +
              ( ( BallY - AttackMaxDeltaPVIntentY ) ^ 2 ) 
      ) ^ 0.5,
      TargetChangeDistance = (
          ( ( AttackMaxDeltaPVIntentX - AttackMaxDeltaPVX ) ^ 2 ) +
              ( ( AttackMaxDeltaPVIntentY - AttackMaxDeltaPVY ) ^ 2 ) 
      ) ^ 0.5
  )
]

if ( F ) {
    
  ggplot() +
     geom_boxplot(
        data = dtPVDelta[
           AttackingTeam == Team, 
           .SD[1], 
           Frame
        ][,
           list(
              Team,
              PassDistance = (
                 ( ( BallX - AttackMaxDeltaPVX ) ^ 2 ) +
                    ( ( BallY - AttackMaxDeltaPVY ) ^ 2 ) 
              ) ^ 0.5,
              PassIntentDistance = (
                 ( ( BallX - AttackMaxDeltaPVIntentX ) ^ 2 ) +
                    ( ( BallY - AttackMaxDeltaPVIntentY ) ^ 2 ) 
              ) ^ 0.5,
              TargetChangeDistance = (
                 ( ( AttackMaxDeltaPVIntentX - AttackMaxDeltaPVX ) ^ 2 ) +
                    ( ( AttackMaxDeltaPVIntentY - AttackMaxDeltaPVY ) ^ 2 ) 
              ) ^ 0.5
           )
        ],
        aes(
           x = 10 * ( PassDistance %/% 10 ),
           # y = TargetChangeDistance,
           y = PassIntentDistance - PassDistance,
           group = paste0(Team, 10 * ( PassDistance %/% 10 )),
           color = Team
        ),
        fill = 'transparent'
     )

}

ggplot(
    dtPVDeltaChange[, 
      .N, 
      list(
          Team, 
          PassDistance = 10 * floor(PassDistance/10), 
          # PassIntentDistance = 10 * floor(PassIntentDistance/10),
          ChangeInDistance = round(PassIntentDistance - PassDistance, -1)
      )
    ][, 
      list(ChangeInDistance, N, N_pct = N/sum(N)), 
      list(Team, PassDistance)
    ]
) + 
    geom_tile(aes(x = PassDistance, y = ChangeInDistance, alpha = N_pct)) +
    geom_label(aes(x = PassDistance, y = ChangeInDistance, label = N)) +
    # geom_text(aes(x = PassDistance, y = ChangeInDistance, label = round(N_pct,2))) +
    scale_alpha_continuous(labels = percent, name = 'Percent over\npass distance\nbucket') +
    facet_wrap(~Team) +
    scale_x_continuous(name = 'Optimal outcome model pass distance') +
    scale_y_continuous(name = 'Optimal outcome model pass distance -\noptimal intent model pass distance') +
    coord_fixed()

```

- Long passes are more likely to be in areas with small pockets of space ( no proof for this statement but from watching the game ) so the fact that we include the possibility of slightly wayward passes means the reward of _intending_ to pass to them reduces.
- It's a little odd that the longest passes aren't as affected as the medium range passes. A lot of these passes are the ones out to the wing and you can see that in many cases the optimal target just moves inwards a bit which is enough for these targets to still remain pretty far from the ball but not be as risky.

( We use a distance based noise function because we expect longer passes to be harder to execute. The trend of longer passes seeing a more drastic change might be a self-fulfilling result as a consequence of our formulation of noise. Some day we'll have a good passing inaccuracy model and then we'll know. )

The distance between the two optimal locations -

```{r DistanceShift, echo=FALSE}

ggplot(
    dtPVDeltaChange[, 
      .N, 
      list(
          Team, 
          PassDistance = 10 * floor(PassDistance/10), 
          # PassIntentDistance = 10 * floor(PassIntentDistance/10),
          TargetChangeDistance = round(TargetChangeDistance, -1)
      )
    ][, 
      list(TargetChangeDistance, N, N_pct = N/sum(N)), 
      list(Team, PassDistance)
    ]
) + 
    geom_tile(aes(x = PassDistance, y = TargetChangeDistance, alpha = N_pct)) +
    geom_label(aes(x = PassDistance, y = TargetChangeDistance, label = N)) +
    # geom_text(aes(x = PassDistance, y = ChangeInDistance, label = round(N_pct,2))) +
    scale_alpha_continuous(labels = percent, name = 'Percent over\npass distance\nbucket') +
    facet_wrap(~Team) +
    scale_x_continuous(name = 'Optimal outcome model pass distance') +
    scale_y_continuous(name = 'Distance between optimal outcome model target\nand optimal intent model target') +
    coord_fixed()

```

Most of the time is is within 10 units ( 1/12th the length of the pitch ) which means they are close enough to each that is probably doesn't matter much. There are many cases though where this distance is quite large, i.e. cases the two locations are farther apart than 10 units. Those cases are where an intent based model is evaluating the situation and evaluating the options better than an outcome based model.

```{r DistanceShiftHigh, echo=FALSE}
kable(dtPVDeltaChange[, .N, list(Team, TargetChangeDistance > 10)][, list(HighDistance = paste0(round(100* N[TargetChangeDistance == T]/sum(N)), '%')), Team])
```

## Conclusion

The difference between the expected reward from an intention and an outcome is noteworthy.

There are a lot of simple assumptions built into this analysis. It would be useful to validate those assumptions from data, which I don't think we can do from publicly available resources though.

## Acknowledgements

- Metrica Sports for the public data
- William Spearman for the pitch control model
- Laurie Shaw for code for the pitch control model - https://github.com/Friends-of-Tracking-Data-FoTD/LaurieOnTracking/blob/master/Tutorial3_PitchControl.py and the possession value map - https://github.com/Friends-of-Tracking-Data-FoTD/LaurieOnTracking/blob/master/EPV_grid.csv
- Friends of Tracking for making these resources public
- Javier Fernandez, Luke Bornn, Dan Cervone for the EPV paper - http://www.lukebornn.com/papers/fernandez_sloan_2019.pdf

## Get in touch 

On Twitter - @thecomeonman, or on mail - mail dot thecomeonman at gmail dot com
